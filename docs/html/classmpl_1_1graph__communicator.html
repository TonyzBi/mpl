<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Message Passing Library: mpl::graph_communicator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Message Passing Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classmpl_1_1graph__communicator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classmpl_1_1graph__communicator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mpl::graph_communicator Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Communicator with general graph topology.  
 <a href="classmpl_1_1graph__communicator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="graph__communicator_8hpp_source.html">graph_communicator.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mpl::graph_communicator:</div>
<div class="dyncontent">
<div class="center"><img src="classmpl_1_1graph__communicator__inherit__graph.png" border="0" usemap="#ampl_1_1graph__communicator_inherit__map" alt="Inheritance graph"/></div>
<map name="ampl_1_1graph__communicator_inherit__map" id="ampl_1_1graph__communicator_inherit__map">
<area shape="rect" title="Communicator with general graph topology." alt="" coords="31,1359,283,1600"/>
<area shape="rect" href="classmpl_1_1impl_1_1topology__communicator.html" title="Base class for communicators with a topology." alt="" coords="25,931,288,1311"/>
<area shape="rect" href="classmpl_1_1communicator.html" title="Specifies the communication context for a communication operation." alt="" coords="61,468,253,883"/>
<area shape="rect" href="classmpl_1_1impl_1_1base__communicator.html" title=" " alt="" coords="5,5,308,420"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for mpl::graph_communicator:</div>
<div class="dyncontent">
<div class="center"><img src="classmpl_1_1graph__communicator__coll__graph.png" border="0" usemap="#ampl_1_1graph__communicator_coll__map" alt="Collaboration graph"/></div>
<map name="ampl_1_1graph__communicator_coll__map" id="ampl_1_1graph__communicator_coll__map">
<area shape="rect" title="Communicator with general graph topology." alt="" coords="520,1479,772,1720"/>
<area shape="rect" href="classmpl_1_1impl_1_1topology__communicator.html" title="Base class for communicators with a topology." alt="" coords="515,1049,777,1429"/>
<area shape="rect" href="classmpl_1_1communicator.html" title="Specifies the communication context for a communication operation." alt="" coords="550,585,742,1000"/>
<area shape="rect" href="classmpl_1_1impl_1_1base__communicator.html" title=" " alt="" coords="495,173,797,536"/>
<area shape="rect" href="classmpl_1_1impl_1_1base__communicator_1_1comm__collective__tag.html" title="Indicates the creation of a new communicator by an operation that is collective for all processes in ..." alt="" coords="5,5,308,108"/>
<area shape="rect" href="classmpl_1_1impl_1_1base__communicator_1_1group__collective__tag.html" title="Indicates the creation of a new communicator by an operation that is collective for all processes in ..." alt="" coords="332,5,635,108"/>
<area shape="rect" href="classmpl_1_1impl_1_1base__communicator_1_1split__tag.html" title="Indicates the creation of a new communicator by spitting an existing communicator into disjoint subgr..." alt="" coords="659,5,961,108"/>
<area shape="rect" href="classmpl_1_1impl_1_1base__communicator_1_1split__shared__memory__tag.html" title="Indicates the creation of a new communicator by spitting an existing communicator into disjoint subgr..." alt="" coords="985,5,1288,108"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1graph__communicator_1_1edge__set.html">edge_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of edges, pairs of nodes represented by non-negative integers.  <a href="classmpl_1_1graph__communicator_1_1edge__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1graph__communicator_1_1node__list.html">node_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of nodes represented by integers.  <a href="classmpl_1_1graph__communicator_1_1node__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af66054a704ac25557aa25b356e8abd63"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a> { <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63aee0cbdbacdada19376449799774976e8">identical</a> = MPI_IDENT
, <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63aecf9c13ef0ea0b37562355d0c5f982ac">congruent</a> = MPI_CONGRUENT
, <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63a10faae554c642e7607b1dd0cc8607703">similar</a> = MPI_SIMILAR
, <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63ab4f45c85d7e3269abe7f894d94bf0f29">unequal</a> = MPI_UNEQUAL
 }</td></tr>
<tr class="memdesc:af66054a704ac25557aa25b356e8abd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality types for communicator comparison.  <a href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">More...</a><br /></td></tr>
<tr class="separator:af66054a704ac25557aa25b356e8abd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af81016b2d1c45d91880894f13ba74182"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1graph__communicator.html#af81016b2d1c45d91880894f13ba74182">graph_communicator</a> ()=default</td></tr>
<tr class="memdesc:af81016b2d1c45d91880894f13ba74182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty communicator with no associated process.  <a href="classmpl_1_1graph__communicator.html#af81016b2d1c45d91880894f13ba74182">More...</a><br /></td></tr>
<tr class="separator:af81016b2d1c45d91880894f13ba74182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4242c2300ed9c2d844001847027b148"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1graph__communicator.html#ab4242c2300ed9c2d844001847027b148">graph_communicator</a> (const <a class="el" href="classmpl_1_1graph__communicator.html">graph_communicator</a> &amp;other)</td></tr>
<tr class="memdesc:ab4242c2300ed9c2d844001847027b148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new communicator which is equivalent to an existing one.  <a href="classmpl_1_1graph__communicator.html#ab4242c2300ed9c2d844001847027b148">More...</a><br /></td></tr>
<tr class="separator:ab4242c2300ed9c2d844001847027b148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0053567d5a44c1783b35050f25f99ff0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1graph__communicator.html#a0053567d5a44c1783b35050f25f99ff0">graph_communicator</a> (<a class="el" href="classmpl_1_1graph__communicator.html">graph_communicator</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a0053567d5a44c1783b35050f25f99ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs a communicator.  <a href="classmpl_1_1graph__communicator.html#a0053567d5a44c1783b35050f25f99ff0">More...</a><br /></td></tr>
<tr class="separator:a0053567d5a44c1783b35050f25f99ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b838df23d3b54ac7ff8f249e2a59e64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1graph__communicator.html#a9b838df23d3b54ac7ff8f249e2a59e64">graph_communicator</a> (const <a class="el" href="classmpl_1_1communicator.html">communicator</a> &amp;other, const <a class="el" href="classmpl_1_1graph__communicator_1_1edge__set.html">edge_set</a> &amp;edges, bool reorder=true)</td></tr>
<tr class="memdesc:a9b838df23d3b54ac7ff8f249e2a59e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new communicator with graph process topology.  <a href="classmpl_1_1graph__communicator.html#a9b838df23d3b54ac7ff8f249e2a59e64">More...</a><br /></td></tr>
<tr class="separator:a9b838df23d3b54ac7ff8f249e2a59e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce11d71ed0d0398316f5a5669b5bdbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1graph__communicator.html">graph_communicator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1graph__communicator.html#adce11d71ed0d0398316f5a5669b5bdbf">operator=</a> (const <a class="el" href="classmpl_1_1graph__communicator.html">graph_communicator</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:adce11d71ed0d0398316f5a5669b5bdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assigns and creates a new communicator with graph process topology which is equivalent to an existing one.  <a href="classmpl_1_1graph__communicator.html#adce11d71ed0d0398316f5a5669b5bdbf">More...</a><br /></td></tr>
<tr class="separator:adce11d71ed0d0398316f5a5669b5bdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c706fcf6770f01b69256c7f76c97222"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1graph__communicator.html">graph_communicator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1graph__communicator.html#a9c706fcf6770f01b69256c7f76c97222">operator=</a> (<a class="el" href="classmpl_1_1graph__communicator.html">graph_communicator</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a9c706fcf6770f01b69256c7f76c97222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigns a communicator.  <a href="classmpl_1_1graph__communicator.html#a9c706fcf6770f01b69256c7f76c97222">More...</a><br /></td></tr>
<tr class="separator:a9c706fcf6770f01b69256c7f76c97222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545def7768f6786e06c36277c1d21cde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1graph__communicator.html#a545def7768f6786e06c36277c1d21cde">degree</a> (int <a class="el" href="classmpl_1_1communicator.html#ae07d74b4f28b45e4bf56777d5d2a9789">rank</a>) const</td></tr>
<tr class="memdesc:a545def7768f6786e06c36277c1d21cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of neighbours of some process.  <a href="classmpl_1_1graph__communicator.html#a545def7768f6786e06c36277c1d21cde">More...</a><br /></td></tr>
<tr class="separator:a545def7768f6786e06c36277c1d21cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17dd29d46d12c1cafd0d4b9f7aa4f8e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1graph__communicator.html#a17dd29d46d12c1cafd0d4b9f7aa4f8e7">degree</a> () const</td></tr>
<tr class="memdesc:a17dd29d46d12c1cafd0d4b9f7aa4f8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of neighbours of the calling process.  <a href="classmpl_1_1graph__communicator.html#a17dd29d46d12c1cafd0d4b9f7aa4f8e7">More...</a><br /></td></tr>
<tr class="separator:a17dd29d46d12c1cafd0d4b9f7aa4f8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad517010b26940090a839b6ef0c3d95ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1graph__communicator_1_1node__list.html">node_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1graph__communicator.html#ad517010b26940090a839b6ef0c3d95ad">neighbors</a> (int <a class="el" href="classmpl_1_1communicator.html#ae07d74b4f28b45e4bf56777d5d2a9789">rank</a>) const</td></tr>
<tr class="memdesc:ad517010b26940090a839b6ef0c3d95ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the neighbours of some process.  <a href="classmpl_1_1graph__communicator.html#ad517010b26940090a839b6ef0c3d95ad">More...</a><br /></td></tr>
<tr class="separator:ad517010b26940090a839b6ef0c3d95ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39af30840dbd4cdefb3c91b96f80a40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1graph__communicator_1_1node__list.html">node_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1graph__communicator.html#af39af30840dbd4cdefb3c91b96f80a40">neighbors</a> () const</td></tr>
<tr class="memdesc:af39af30840dbd4cdefb3c91b96f80a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the neighbours of the calling process.  <a href="classmpl_1_1graph__communicator.html#af39af30840dbd4cdefb3c91b96f80a40">More...</a><br /></td></tr>
<tr class="separator:af39af30840dbd4cdefb3c91b96f80a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c7b3d19a5af4ba0f30e40045a2e459"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43c7b3d19a5af4ba0f30e40045a2e459"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a43c7b3d19a5af4ba0f30e40045a2e459">neighbor_allgather</a> (const T &amp;senddata, T *recvdata) const</td></tr>
<tr class="memdesc:a43c7b3d19a5af4ba0f30e40045a2e459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all neighboring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a43c7b3d19a5af4ba0f30e40045a2e459">More...</a><br /></td></tr>
<tr class="separator:a43c7b3d19a5af4ba0f30e40045a2e459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ce31d403e1e2c143acb593ca1b21c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af3ce31d403e1e2c143acb593ca1b21c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#af3ce31d403e1e2c143acb593ca1b21c2">neighbor_allgather</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:af3ce31d403e1e2c143acb593ca1b21c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all neighboring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#af3ce31d403e1e2c143acb593ca1b21c2">More...</a><br /></td></tr>
<tr class="separator:af3ce31d403e1e2c143acb593ca1b21c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dc51499372d1bbef91b06a93f9c275"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48dc51499372d1bbef91b06a93f9c275"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a48dc51499372d1bbef91b06a93f9c275">ineighbor_allgather</a> (const T &amp;senddata, T *recvdata) const</td></tr>
<tr class="memdesc:a48dc51499372d1bbef91b06a93f9c275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all neighboring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a48dc51499372d1bbef91b06a93f9c275">More...</a><br /></td></tr>
<tr class="separator:a48dc51499372d1bbef91b06a93f9c275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0106f906615b9eed23c4261abba478d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0106f906615b9eed23c4261abba478d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a0106f906615b9eed23c4261abba478d7">ineighbor_allgather</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a0106f906615b9eed23c4261abba478d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all neighboring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a0106f906615b9eed23c4261abba478d7">More...</a><br /></td></tr>
<tr class="separator:a0106f906615b9eed23c4261abba478d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377702be1b30166ad458fcef11b2c239"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a377702be1b30166ad458fcef11b2c239"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a377702be1b30166ad458fcef11b2c239">neighbor_allgatherv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:a377702be1b30166ad458fcef11b2c239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all neighbouring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a377702be1b30166ad458fcef11b2c239">More...</a><br /></td></tr>
<tr class="separator:a377702be1b30166ad458fcef11b2c239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5822b089b634a670a9f3cef6e37dcef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af5822b089b634a670a9f3cef6e37dcef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#af5822b089b634a670a9f3cef6e37dcef">neighbor_allgatherv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:af5822b089b634a670a9f3cef6e37dcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all neighbouring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#af5822b089b634a670a9f3cef6e37dcef">More...</a><br /></td></tr>
<tr class="separator:af5822b089b634a670a9f3cef6e37dcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689162e612c758a55f27811051323739"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a689162e612c758a55f27811051323739"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a689162e612c758a55f27811051323739">ineighbor_allgatherv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:a689162e612c758a55f27811051323739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all neighbouring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a689162e612c758a55f27811051323739">More...</a><br /></td></tr>
<tr class="separator:a689162e612c758a55f27811051323739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5b018990b3ec2bb3c7daf6f5eae11a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd5b018990b3ec2bb3c7daf6f5eae11a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#abd5b018990b3ec2bb3c7daf6f5eae11a">ineighbor_allgatherv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:abd5b018990b3ec2bb3c7daf6f5eae11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all neighbouring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#abd5b018990b3ec2bb3c7daf6f5eae11a">More...</a><br /></td></tr>
<tr class="separator:abd5b018990b3ec2bb3c7daf6f5eae11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03afcae482e770e40ca5df7ae77b29c6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03afcae482e770e40ca5df7ae77b29c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a03afcae482e770e40ca5df7ae77b29c6">neighbor_alltoall</a> (const T *senddata, T *recvdata) const</td></tr>
<tr class="memdesc:a03afcae482e770e40ca5df7ae77b29c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all neighbouring processes and receives messages from all neighbouring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a03afcae482e770e40ca5df7ae77b29c6">More...</a><br /></td></tr>
<tr class="separator:a03afcae482e770e40ca5df7ae77b29c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455d8703c09913eebe31cd360351c308"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a455d8703c09913eebe31cd360351c308"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a455d8703c09913eebe31cd360351c308">neighbor_alltoall</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a455d8703c09913eebe31cd360351c308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all neighbouring processes and receives messages from all neighbouring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a455d8703c09913eebe31cd360351c308">More...</a><br /></td></tr>
<tr class="separator:a455d8703c09913eebe31cd360351c308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b9bcc6355597f6294e82b22687c116"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a52b9bcc6355597f6294e82b22687c116"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a52b9bcc6355597f6294e82b22687c116">ineighbor_alltoall</a> (const T *senddata, T *recvdata) const</td></tr>
<tr class="memdesc:a52b9bcc6355597f6294e82b22687c116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all neighbouring processes and receives messages from all neighbouring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a52b9bcc6355597f6294e82b22687c116">More...</a><br /></td></tr>
<tr class="separator:a52b9bcc6355597f6294e82b22687c116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd0c6abb90218c58a6a02a9b6428231"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fd0c6abb90218c58a6a02a9b6428231"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a6fd0c6abb90218c58a6a02a9b6428231">ineighbor_alltoall</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a6fd0c6abb90218c58a6a02a9b6428231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all neighbouring processes and receives messages from all neighbouring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a6fd0c6abb90218c58a6a02a9b6428231">More...</a><br /></td></tr>
<tr class="separator:a6fd0c6abb90218c58a6a02a9b6428231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2dc41f3f09788b9dd87be27981668a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada2dc41f3f09788b9dd87be27981668a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#ada2dc41f3f09788b9dd87be27981668a">neighbor_alltoallv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;senddispls, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:ada2dc41f3f09788b9dd87be27981668a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#ada2dc41f3f09788b9dd87be27981668a">More...</a><br /></td></tr>
<tr class="separator:ada2dc41f3f09788b9dd87be27981668a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54da0c73668349841c941c53c6acff81"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54da0c73668349841c941c53c6acff81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a54da0c73668349841c941c53c6acff81">neighbor_alltoallv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:a54da0c73668349841c941c53c6acff81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a54da0c73668349841c941c53c6acff81">More...</a><br /></td></tr>
<tr class="separator:a54da0c73668349841c941c53c6acff81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3b9fce1c6ada4e1110ac9694a19422"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf3b9fce1c6ada4e1110ac9694a19422"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#aaf3b9fce1c6ada4e1110ac9694a19422">ineighbor_alltoallv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;senddispls, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:aaf3b9fce1c6ada4e1110ac9694a19422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#aaf3b9fce1c6ada4e1110ac9694a19422">More...</a><br /></td></tr>
<tr class="separator:aaf3b9fce1c6ada4e1110ac9694a19422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962c6eec0ae1ff20d3569fd3f10d2471"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a962c6eec0ae1ff20d3569fd3f10d2471"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1topology__communicator.html#a962c6eec0ae1ff20d3569fd3f10d2471">ineighbor_alltoallv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:a962c6eec0ae1ff20d3569fd3f10d2471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1topology__communicator.html#a962c6eec0ae1ff20d3569fd3f10d2471">More...</a><br /></td></tr>
<tr class="separator:a962c6eec0ae1ff20d3569fd3f10d2471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1bd8f32c690ee7a31456da2c437bdf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#abe1bd8f32c690ee7a31456da2c437bdf">size</a> () const</td></tr>
<tr class="memdesc:abe1bd8f32c690ee7a31456da2c437bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the total number of processes in a communicator.  <a href="classmpl_1_1communicator.html#abe1bd8f32c690ee7a31456da2c437bdf">More...</a><br /></td></tr>
<tr class="separator:abe1bd8f32c690ee7a31456da2c437bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07d74b4f28b45e4bf56777d5d2a9789"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ae07d74b4f28b45e4bf56777d5d2a9789">rank</a> () const</td></tr>
<tr class="memdesc:ae07d74b4f28b45e4bf56777d5d2a9789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the rank within a communicator.  <a href="classmpl_1_1communicator.html#ae07d74b4f28b45e4bf56777d5d2a9789">More...</a><br /></td></tr>
<tr class="separator:ae07d74b4f28b45e4bf56777d5d2a9789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153a492a90432d228638e2548b2a65b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a153a492a90432d228638e2548b2a65b5">operator==</a> (const <a class="el" href="classmpl_1_1communicator.html">communicator</a> &amp;other) const</td></tr>
<tr class="memdesc:a153a492a90432d228638e2548b2a65b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for identity of communicators.  <a href="classmpl_1_1communicator.html#a153a492a90432d228638e2548b2a65b5">More...</a><br /></td></tr>
<tr class="separator:a153a492a90432d228638e2548b2a65b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3f30e3e33676cfbd8f3757082949cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#aea3f30e3e33676cfbd8f3757082949cd">operator!=</a> (const <a class="el" href="classmpl_1_1communicator.html">communicator</a> &amp;other) const</td></tr>
<tr class="memdesc:aea3f30e3e33676cfbd8f3757082949cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for identity of communicators.  <a href="classmpl_1_1communicator.html#aea3f30e3e33676cfbd8f3757082949cd">More...</a><br /></td></tr>
<tr class="separator:aea3f30e3e33676cfbd8f3757082949cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b672d71b83fafca8f6bf4d435331180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a7b672d71b83fafca8f6bf4d435331180">compare</a> (const <a class="el" href="classmpl_1_1communicator.html">communicator</a> &amp;other) const</td></tr>
<tr class="memdesc:a7b672d71b83fafca8f6bf4d435331180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares to another communicator.  <a href="classmpl_1_1communicator.html#a7b672d71b83fafca8f6bf4d435331180">More...</a><br /></td></tr>
<tr class="separator:a7b672d71b83fafca8f6bf4d435331180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad709e10e351d9ffd4dd9917a9b697c19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad709e10e351d9ffd4dd9917a9b697c19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ad709e10e351d9ffd4dd9917a9b697c19">alltoall</a> (T *sendrecvdata) const</td></tr>
<tr class="memdesc:ad709e10e351d9ffd4dd9917a9b697c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes, in-place version.  <a href="classmpl_1_1communicator.html#ad709e10e351d9ffd4dd9917a9b697c19">More...</a><br /></td></tr>
<tr class="separator:ad709e10e351d9ffd4dd9917a9b697c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88368d3f4d7b375825ba839746aea7dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88368d3f4d7b375825ba839746aea7dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a88368d3f4d7b375825ba839746aea7dd">alltoall</a> (T *sendrecvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendrecvl) const</td></tr>
<tr class="memdesc:a88368d3f4d7b375825ba839746aea7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes, in-place version.  <a href="classmpl_1_1communicator.html#a88368d3f4d7b375825ba839746aea7dd">More...</a><br /></td></tr>
<tr class="separator:a88368d3f4d7b375825ba839746aea7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5ca17cb762ed1e57d213a5a07f3752"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f5ca17cb762ed1e57d213a5a07f3752"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a3f5ca17cb762ed1e57d213a5a07f3752">alltoall</a> (const T *senddata, T *recvdata) const</td></tr>
<tr class="memdesc:a3f5ca17cb762ed1e57d213a5a07f3752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes.  <a href="classmpl_1_1communicator.html#a3f5ca17cb762ed1e57d213a5a07f3752">More...</a><br /></td></tr>
<tr class="separator:a3f5ca17cb762ed1e57d213a5a07f3752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f751fb0c400872c55249220e2d8eb99"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f751fb0c400872c55249220e2d8eb99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a2f751fb0c400872c55249220e2d8eb99">alltoall</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a2f751fb0c400872c55249220e2d8eb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes.  <a href="classmpl_1_1communicator.html#a2f751fb0c400872c55249220e2d8eb99">More...</a><br /></td></tr>
<tr class="separator:a2f751fb0c400872c55249220e2d8eb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb9f14a7a9f9bd44eae7832daed895d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aadb9f14a7a9f9bd44eae7832daed895d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#aadb9f14a7a9f9bd44eae7832daed895d">ialltoall</a> (T *sendrecvdata) const</td></tr>
<tr class="memdesc:aadb9f14a7a9f9bd44eae7832daed895d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes in a non-blocking manner, in-place version.  <a href="classmpl_1_1communicator.html#aadb9f14a7a9f9bd44eae7832daed895d">More...</a><br /></td></tr>
<tr class="separator:aadb9f14a7a9f9bd44eae7832daed895d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe91007be7acef7641d6cbb08526d53b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe91007be7acef7641d6cbb08526d53b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#abe91007be7acef7641d6cbb08526d53b">ialltoall</a> (T *sendrecvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendrecvl) const</td></tr>
<tr class="memdesc:abe91007be7acef7641d6cbb08526d53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes in a non-blocking manner, in-place version.  <a href="classmpl_1_1communicator.html#abe91007be7acef7641d6cbb08526d53b">More...</a><br /></td></tr>
<tr class="separator:abe91007be7acef7641d6cbb08526d53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6340db4f70de6bd6877daa489e5a9cee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6340db4f70de6bd6877daa489e5a9cee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a6340db4f70de6bd6877daa489e5a9cee">ialltoall</a> (const T *senddata, T *recvdata) const</td></tr>
<tr class="memdesc:a6340db4f70de6bd6877daa489e5a9cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#a6340db4f70de6bd6877daa489e5a9cee">More...</a><br /></td></tr>
<tr class="separator:a6340db4f70de6bd6877daa489e5a9cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78219b6f443eb6ab610691db2c63b1f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab78219b6f443eb6ab610691db2c63b1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ab78219b6f443eb6ab610691db2c63b1f">ialltoall</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:ab78219b6f443eb6ab610691db2c63b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages to all processes and receives messages from all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#ab78219b6f443eb6ab610691db2c63b1f">More...</a><br /></td></tr>
<tr class="separator:ab78219b6f443eb6ab610691db2c63b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db43a46f468c60e84b35f95577ff0f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4db43a46f468c60e84b35f95577ff0f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a4db43a46f468c60e84b35f95577ff0f4">alltoallv</a> (T *sendrecvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendrecvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;sendrecvdispls) const</td></tr>
<tr class="memdesc:a4db43a46f468c60e84b35f95577ff0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes, in-place variant.  <a href="classmpl_1_1communicator.html#a4db43a46f468c60e84b35f95577ff0f4">More...</a><br /></td></tr>
<tr class="separator:a4db43a46f468c60e84b35f95577ff0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb7048f892b4c371bba2e261e565656"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afcb7048f892b4c371bba2e261e565656"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#afcb7048f892b4c371bba2e261e565656">alltoallv</a> (T *sendrecvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendrecvls) const</td></tr>
<tr class="memdesc:afcb7048f892b4c371bba2e261e565656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes, in-place variant.  <a href="classmpl_1_1communicator.html#afcb7048f892b4c371bba2e261e565656">More...</a><br /></td></tr>
<tr class="separator:afcb7048f892b4c371bba2e261e565656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9edec8368db00f56b7fe7c648b60eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade9edec8368db00f56b7fe7c648b60eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ade9edec8368db00f56b7fe7c648b60eb">alltoallv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;senddispls, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:ade9edec8368db00f56b7fe7c648b60eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes.  <a href="classmpl_1_1communicator.html#ade9edec8368db00f56b7fe7c648b60eb">More...</a><br /></td></tr>
<tr class="separator:ade9edec8368db00f56b7fe7c648b60eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f25701315e92089bf34cf63aba4b56"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38f25701315e92089bf34cf63aba4b56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a38f25701315e92089bf34cf63aba4b56">alltoallv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:a38f25701315e92089bf34cf63aba4b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes.  <a href="classmpl_1_1communicator.html#a38f25701315e92089bf34cf63aba4b56">More...</a><br /></td></tr>
<tr class="separator:a38f25701315e92089bf34cf63aba4b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5664d9591456924a7343082445bc8452"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5664d9591456924a7343082445bc8452"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a5664d9591456924a7343082445bc8452">ialltoallv</a> (T *sendrecvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendrecvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;sendrecvdispls) const</td></tr>
<tr class="memdesc:a5664d9591456924a7343082445bc8452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a5664d9591456924a7343082445bc8452">More...</a><br /></td></tr>
<tr class="separator:a5664d9591456924a7343082445bc8452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abdf44a7c377ba7191cb4abc6648afe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7abdf44a7c377ba7191cb4abc6648afe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a7abdf44a7c377ba7191cb4abc6648afe">ialltoallv</a> (T *sendrecvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendrecvls) const</td></tr>
<tr class="memdesc:a7abdf44a7c377ba7191cb4abc6648afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a7abdf44a7c377ba7191cb4abc6648afe">More...</a><br /></td></tr>
<tr class="separator:a7abdf44a7c377ba7191cb4abc6648afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e1317ecddf63366a5398f1d83dfb33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4e1317ecddf63366a5398f1d83dfb33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ad4e1317ecddf63366a5398f1d83dfb33">ialltoallv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;senddispls, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:ad4e1317ecddf63366a5398f1d83dfb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#ad4e1317ecddf63366a5398f1d83dfb33">More...</a><br /></td></tr>
<tr class="separator:ad4e1317ecddf63366a5398f1d83dfb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b622fafeeb9d6a637e17d244c24deac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b622fafeeb9d6a637e17d244c24deac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a0b622fafeeb9d6a637e17d244c24deac">ialltoallv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:a0b622fafeeb9d6a637e17d244c24deac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#a0b622fafeeb9d6a637e17d244c24deac">More...</a><br /></td></tr>
<tr class="separator:a0b622fafeeb9d6a637e17d244c24deac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb886db659e8bc352ca70800704b8956"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:adb886db659e8bc352ca70800704b8956"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#adb886db659e8bc352ca70800704b8956">reduce</a> (F f, int root_rank, T &amp;sendrecvdata) const</td></tr>
<tr class="memdesc:adb886db659e8bc352ca70800704b8956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes, in-place variant.  <a href="classmpl_1_1communicator.html#adb886db659e8bc352ca70800704b8956">More...</a><br /></td></tr>
<tr class="separator:adb886db659e8bc352ca70800704b8956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494c7c1849713e45d99d901b31250b35"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a494c7c1849713e45d99d901b31250b35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a494c7c1849713e45d99d901b31250b35">reduce</a> (F f, int root_rank, const T &amp;senddata) const</td></tr>
<tr class="memdesc:a494c7c1849713e45d99d901b31250b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes, non-root in-place variant.  <a href="classmpl_1_1communicator.html#a494c7c1849713e45d99d901b31250b35">More...</a><br /></td></tr>
<tr class="separator:a494c7c1849713e45d99d901b31250b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3643fa3e833c9dfb4eaf871235aed3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:aae3643fa3e833c9dfb4eaf871235aed3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#aae3643fa3e833c9dfb4eaf871235aed3">reduce</a> (F f, int root_rank, T *sendrecvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:aae3643fa3e833c9dfb4eaf871235aed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes, in-place variant.  <a href="classmpl_1_1communicator.html#aae3643fa3e833c9dfb4eaf871235aed3">More...</a><br /></td></tr>
<tr class="separator:aae3643fa3e833c9dfb4eaf871235aed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2415ddb3e27cce97fd5317f781a86c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:aed2415ddb3e27cce97fd5317f781a86c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#aed2415ddb3e27cce97fd5317f781a86c">reduce</a> (F f, int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:aed2415ddb3e27cce97fd5317f781a86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes, non-root in-place variant.  <a href="classmpl_1_1communicator.html#aed2415ddb3e27cce97fd5317f781a86c">More...</a><br /></td></tr>
<tr class="separator:aed2415ddb3e27cce97fd5317f781a86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83611f07b8b4d986e4afd1f93928c887"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a83611f07b8b4d986e4afd1f93928c887"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a83611f07b8b4d986e4afd1f93928c887">reduce</a> (F f, int root_rank, const T &amp;senddata, T &amp;recvdata) const</td></tr>
<tr class="memdesc:a83611f07b8b4d986e4afd1f93928c887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes.  <a href="classmpl_1_1communicator.html#a83611f07b8b4d986e4afd1f93928c887">More...</a><br /></td></tr>
<tr class="separator:a83611f07b8b4d986e4afd1f93928c887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f35d0b54b37c35d4a9408988afebaec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a6f35d0b54b37c35d4a9408988afebaec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a6f35d0b54b37c35d4a9408988afebaec">reduce</a> (F f, int root_rank, const T *senddata, T *recvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a6f35d0b54b37c35d4a9408988afebaec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes.  <a href="classmpl_1_1communicator.html#a6f35d0b54b37c35d4a9408988afebaec">More...</a><br /></td></tr>
<tr class="separator:a6f35d0b54b37c35d4a9408988afebaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2342955984c4db387d52a5414b212c5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ad2342955984c4db387d52a5414b212c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ad2342955984c4db387d52a5414b212c5">ireduce</a> (F f, int root_rank, T &amp;sendrecvdata) const</td></tr>
<tr class="memdesc:ad2342955984c4db387d52a5414b212c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#ad2342955984c4db387d52a5414b212c5">More...</a><br /></td></tr>
<tr class="separator:ad2342955984c4db387d52a5414b212c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e5f4cd63cf9354ceedc4da193e2410"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a79e5f4cd63cf9354ceedc4da193e2410"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a79e5f4cd63cf9354ceedc4da193e2410">ireduce</a> (F f, int root_rank, const T &amp;senddata) const</td></tr>
<tr class="memdesc:a79e5f4cd63cf9354ceedc4da193e2410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes in a non-blocking manner, non-root in-place variant.  <a href="classmpl_1_1communicator.html#a79e5f4cd63cf9354ceedc4da193e2410">More...</a><br /></td></tr>
<tr class="separator:a79e5f4cd63cf9354ceedc4da193e2410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06525ff878eb073c02dc0bef285f06ac"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a06525ff878eb073c02dc0bef285f06ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a06525ff878eb073c02dc0bef285f06ac">ireduce</a> (F f, int root_rank, T *sendrecvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a06525ff878eb073c02dc0bef285f06ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes in non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a06525ff878eb073c02dc0bef285f06ac">More...</a><br /></td></tr>
<tr class="separator:a06525ff878eb073c02dc0bef285f06ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb6d8fc8a9aafabf50b96275f09775d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:abdb6d8fc8a9aafabf50b96275f09775d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#abdb6d8fc8a9aafabf50b96275f09775d">ireduce</a> (F f, int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:abdb6d8fc8a9aafabf50b96275f09775d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes in a non-blocking manner, non-root in-place variant.  <a href="classmpl_1_1communicator.html#abdb6d8fc8a9aafabf50b96275f09775d">More...</a><br /></td></tr>
<tr class="separator:abdb6d8fc8a9aafabf50b96275f09775d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4e60d9ca331f32342631fca0c7b74c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:aaf4e60d9ca331f32342631fca0c7b74c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#aaf4e60d9ca331f32342631fca0c7b74c">ireduce</a> (F f, int root_rank, const T &amp;senddata, T &amp;recvdata) const</td></tr>
<tr class="memdesc:aaf4e60d9ca331f32342631fca0c7b74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#aaf4e60d9ca331f32342631fca0c7b74c">More...</a><br /></td></tr>
<tr class="separator:aaf4e60d9ca331f32342631fca0c7b74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4791b4e214575bea26bfd84f8f0ffc93"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a4791b4e214575bea26bfd84f8f0ffc93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a4791b4e214575bea26bfd84f8f0ffc93">ireduce</a> (F f, int root_rank, const T *senddata, T *recvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a4791b4e214575bea26bfd84f8f0ffc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#a4791b4e214575bea26bfd84f8f0ffc93">More...</a><br /></td></tr>
<tr class="separator:a4791b4e214575bea26bfd84f8f0ffc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2866d44cee859fc064e2e32a6710d7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a0a2866d44cee859fc064e2e32a6710d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a0a2866d44cee859fc064e2e32a6710d7">allreduce</a> (F f, T &amp;sendrecvdata) const</td></tr>
<tr class="memdesc:a0a2866d44cee859fc064e2e32a6710d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result, in-place variant.  <a href="classmpl_1_1communicator.html#a0a2866d44cee859fc064e2e32a6710d7">More...</a><br /></td></tr>
<tr class="separator:a0a2866d44cee859fc064e2e32a6710d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55feab940e9c72241215918199931936"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a55feab940e9c72241215918199931936"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a55feab940e9c72241215918199931936">allreduce</a> (F f, T *sendrecvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a55feab940e9c72241215918199931936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result, in-place variant.  <a href="classmpl_1_1communicator.html#a55feab940e9c72241215918199931936">More...</a><br /></td></tr>
<tr class="separator:a55feab940e9c72241215918199931936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ac09052c33e0c84be8ae3ee6d5a334"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ad5ac09052c33e0c84be8ae3ee6d5a334"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ad5ac09052c33e0c84be8ae3ee6d5a334">allreduce</a> (F f, const T &amp;senddata, T &amp;recvdata) const</td></tr>
<tr class="memdesc:ad5ac09052c33e0c84be8ae3ee6d5a334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result.  <a href="classmpl_1_1communicator.html#ad5ac09052c33e0c84be8ae3ee6d5a334">More...</a><br /></td></tr>
<tr class="separator:ad5ac09052c33e0c84be8ae3ee6d5a334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c10d9332032baaf40a9e920f86cb28f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a0c10d9332032baaf40a9e920f86cb28f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a0c10d9332032baaf40a9e920f86cb28f">allreduce</a> (F f, const T *senddata, T *recvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a0c10d9332032baaf40a9e920f86cb28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result.  <a href="classmpl_1_1communicator.html#a0c10d9332032baaf40a9e920f86cb28f">More...</a><br /></td></tr>
<tr class="separator:a0c10d9332032baaf40a9e920f86cb28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce91750a7c77edf43e53ac88e4e8524"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a5ce91750a7c77edf43e53ac88e4e8524"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a5ce91750a7c77edf43e53ac88e4e8524">iallreduce</a> (F f, T &amp;sendrecvdata) const</td></tr>
<tr class="memdesc:a5ce91750a7c77edf43e53ac88e4e8524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a5ce91750a7c77edf43e53ac88e4e8524">More...</a><br /></td></tr>
<tr class="separator:a5ce91750a7c77edf43e53ac88e4e8524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50f2d3ad4ca9b8e917997c0aa211edf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:aa50f2d3ad4ca9b8e917997c0aa211edf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#aa50f2d3ad4ca9b8e917997c0aa211edf">iallreduce</a> (F f, T *sendrecvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:aa50f2d3ad4ca9b8e917997c0aa211edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result in non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#aa50f2d3ad4ca9b8e917997c0aa211edf">More...</a><br /></td></tr>
<tr class="separator:aa50f2d3ad4ca9b8e917997c0aa211edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7300592e555f22a9729addc081136e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a4f7300592e555f22a9729addc081136e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a4f7300592e555f22a9729addc081136e">iallreduce</a> (F f, const T &amp;senddata, T &amp;recvdata) const</td></tr>
<tr class="memdesc:a4f7300592e555f22a9729addc081136e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result in a non-blocking manner.  <a href="classmpl_1_1communicator.html#a4f7300592e555f22a9729addc081136e">More...</a><br /></td></tr>
<tr class="separator:a4f7300592e555f22a9729addc081136e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68d3aa79481f7c1828fc9938e0bd960"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ab68d3aa79481f7c1828fc9938e0bd960"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ab68d3aa79481f7c1828fc9938e0bd960">iallreduce</a> (F f, const T *senddata, T *recvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:ab68d3aa79481f7c1828fc9938e0bd960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and broadcasts the result in a non-blocking manner.  <a href="classmpl_1_1communicator.html#ab68d3aa79481f7c1828fc9938e0bd960">More...</a><br /></td></tr>
<tr class="separator:ab68d3aa79481f7c1828fc9938e0bd960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06dee1bcc8345dc0c83f215dea4aba6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:aa06dee1bcc8345dc0c83f215dea4aba6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#aa06dee1bcc8345dc0c83f215dea4aba6">scan</a> (F f, T &amp;sendrecvdata) const</td></tr>
<tr class="memdesc:aa06dee1bcc8345dc0c83f215dea4aba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (scan) over all processes, in-place variant.  <a href="classmpl_1_1communicator.html#aa06dee1bcc8345dc0c83f215dea4aba6">More...</a><br /></td></tr>
<tr class="separator:aa06dee1bcc8345dc0c83f215dea4aba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6c73aa613bf07ed4790210f10a0f1c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:afe6c73aa613bf07ed4790210f10a0f1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#afe6c73aa613bf07ed4790210f10a0f1c">scan</a> (F f, T *sendrecvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:afe6c73aa613bf07ed4790210f10a0f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (scan) over all processes, in-place variant.  <a href="classmpl_1_1communicator.html#afe6c73aa613bf07ed4790210f10a0f1c">More...</a><br /></td></tr>
<tr class="separator:afe6c73aa613bf07ed4790210f10a0f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3438765595e8f2e405a093fc5e9c205a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a3438765595e8f2e405a093fc5e9c205a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a3438765595e8f2e405a093fc5e9c205a">scan</a> (F f, const T &amp;senddata, T &amp;recvdata) const</td></tr>
<tr class="memdesc:a3438765595e8f2e405a093fc5e9c205a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs partial reduction operation (scan) over all processes.  <a href="classmpl_1_1communicator.html#a3438765595e8f2e405a093fc5e9c205a">More...</a><br /></td></tr>
<tr class="separator:a3438765595e8f2e405a093fc5e9c205a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea16fe68468a0a2dfbfadc10a921fb7f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:aea16fe68468a0a2dfbfadc10a921fb7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#aea16fe68468a0a2dfbfadc10a921fb7f">scan</a> (F f, const T *senddata, T *recvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:aea16fe68468a0a2dfbfadc10a921fb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (scan) over all processes.  <a href="classmpl_1_1communicator.html#aea16fe68468a0a2dfbfadc10a921fb7f">More...</a><br /></td></tr>
<tr class="separator:aea16fe68468a0a2dfbfadc10a921fb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f51295cbdebc4da6dd7ceebef8c0416"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a3f51295cbdebc4da6dd7ceebef8c0416"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a3f51295cbdebc4da6dd7ceebef8c0416">iscan</a> (F f, T &amp;sendrecvdata) const</td></tr>
<tr class="memdesc:a3f51295cbdebc4da6dd7ceebef8c0416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (scan) over all processes in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a3f51295cbdebc4da6dd7ceebef8c0416">More...</a><br /></td></tr>
<tr class="separator:a3f51295cbdebc4da6dd7ceebef8c0416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac514a6fe8a481f7120bc1d105c09ee96"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ac514a6fe8a481f7120bc1d105c09ee96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ac514a6fe8a481f7120bc1d105c09ee96">iscan</a> (F f, T *sendrecvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:ac514a6fe8a481f7120bc1d105c09ee96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction (scan) operation over all processes in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#ac514a6fe8a481f7120bc1d105c09ee96">More...</a><br /></td></tr>
<tr class="separator:ac514a6fe8a481f7120bc1d105c09ee96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0aff638a95a6a0003c3993edf014e1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:afd0aff638a95a6a0003c3993edf014e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#afd0aff638a95a6a0003c3993edf014e1">iscan</a> (F f, const T &amp;senddata, T &amp;recvdata) const</td></tr>
<tr class="memdesc:afd0aff638a95a6a0003c3993edf014e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (scan) over all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#afd0aff638a95a6a0003c3993edf014e1">More...</a><br /></td></tr>
<tr class="separator:afd0aff638a95a6a0003c3993edf014e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521c529ae13117f291a9f4fc5086c22a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a521c529ae13117f291a9f4fc5086c22a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a521c529ae13117f291a9f4fc5086c22a">iscan</a> (F f, const T *senddata, T *recvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a521c529ae13117f291a9f4fc5086c22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (scan) over all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#a521c529ae13117f291a9f4fc5086c22a">More...</a><br /></td></tr>
<tr class="separator:a521c529ae13117f291a9f4fc5086c22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67313aace6a05f58081939eb1d2a4b8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ad67313aace6a05f58081939eb1d2a4b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ad67313aace6a05f58081939eb1d2a4b8">exscan</a> (F f, T &amp;sendrecvdata) const</td></tr>
<tr class="memdesc:ad67313aace6a05f58081939eb1d2a4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (exclusive scan) over all processes, in-place variant.  <a href="classmpl_1_1communicator.html#ad67313aace6a05f58081939eb1d2a4b8">More...</a><br /></td></tr>
<tr class="separator:ad67313aace6a05f58081939eb1d2a4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45585975b4b7cc0795a02abf6494963b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a45585975b4b7cc0795a02abf6494963b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a45585975b4b7cc0795a02abf6494963b">exscan</a> (F f, T *sendrecvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a45585975b4b7cc0795a02abf6494963b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (exclusive scan) over all processes, in-place variant.  <a href="classmpl_1_1communicator.html#a45585975b4b7cc0795a02abf6494963b">More...</a><br /></td></tr>
<tr class="separator:a45585975b4b7cc0795a02abf6494963b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b0a5d186d8bac256432060db9e0303"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a20b0a5d186d8bac256432060db9e0303"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a20b0a5d186d8bac256432060db9e0303">exscan</a> (F f, const T &amp;senddata, T &amp;recvdata) const</td></tr>
<tr class="memdesc:a20b0a5d186d8bac256432060db9e0303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs partial reduction operation (exclusive scan) over all processes.  <a href="classmpl_1_1communicator.html#a20b0a5d186d8bac256432060db9e0303">More...</a><br /></td></tr>
<tr class="separator:a20b0a5d186d8bac256432060db9e0303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2b304977b516e327e5003282ff3fb1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a9d2b304977b516e327e5003282ff3fb1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a9d2b304977b516e327e5003282ff3fb1">exscan</a> (F f, const T *senddata, T *recvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a9d2b304977b516e327e5003282ff3fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (exclusive scan) over all processes.  <a href="classmpl_1_1communicator.html#a9d2b304977b516e327e5003282ff3fb1">More...</a><br /></td></tr>
<tr class="separator:a9d2b304977b516e327e5003282ff3fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20766ee389c97340241ff730eae49475"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a20766ee389c97340241ff730eae49475"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a20766ee389c97340241ff730eae49475">iexscan</a> (F f, T &amp;sendrecvdata) const</td></tr>
<tr class="memdesc:a20766ee389c97340241ff730eae49475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a20766ee389c97340241ff730eae49475">More...</a><br /></td></tr>
<tr class="separator:a20766ee389c97340241ff730eae49475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e43e08af5e8481049731092274aca76"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a8e43e08af5e8481049731092274aca76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a8e43e08af5e8481049731092274aca76">iexscan</a> (F f, T *sendrecvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:a8e43e08af5e8481049731092274aca76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner, in-place variant.  <a href="classmpl_1_1communicator.html#a8e43e08af5e8481049731092274aca76">More...</a><br /></td></tr>
<tr class="separator:a8e43e08af5e8481049731092274aca76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebd5cd79b037726a7570177f63891dc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a2ebd5cd79b037726a7570177f63891dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a2ebd5cd79b037726a7570177f63891dc">iexscan</a> (F f, const T &amp;senddata, T &amp;recvdata) const</td></tr>
<tr class="memdesc:a2ebd5cd79b037726a7570177f63891dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#a2ebd5cd79b037726a7570177f63891dc">More...</a><br /></td></tr>
<tr class="separator:a2ebd5cd79b037726a7570177f63891dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba116e6d2045fde1f15fe6dc14bd0c75"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:aba116e6d2045fde1f15fe6dc14bd0c75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#aba116e6d2045fde1f15fe6dc14bd0c75">iexscan</a> (F f, const T *senddata, T *recvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:aba116e6d2045fde1f15fe6dc14bd0c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner.  <a href="classmpl_1_1communicator.html#aba116e6d2045fde1f15fe6dc14bd0c75">More...</a><br /></td></tr>
<tr class="separator:aba116e6d2045fde1f15fe6dc14bd0c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced8d70b00a3b407fe3dabac27a99aca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aced8d70b00a3b407fe3dabac27a99aca">is_valid</a> () const</td></tr>
<tr class="memdesc:aced8d70b00a3b407fe3dabac27a99aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a communicator is valid, i.e., is not an empty communicator with no associated process.  <a href="classmpl_1_1impl_1_1base__communicator.html#aced8d70b00a3b407fe3dabac27a99aca">More...</a><br /></td></tr>
<tr class="separator:aced8d70b00a3b407fe3dabac27a99aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396840f91fb5d7b62c0f5128eb93d6ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a396840f91fb5d7b62c0f5128eb93d6ca">abort</a> (int err) const</td></tr>
<tr class="memdesc:a396840f91fb5d7b62c0f5128eb93d6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts all processes associated to the communicator.  <a href="classmpl_1_1impl_1_1base__communicator.html#a396840f91fb5d7b62c0f5128eb93d6ca">More...</a><br /></td></tr>
<tr class="separator:a396840f91fb5d7b62c0f5128eb93d6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b0e731726a939727ff816a614d241b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac3b0e731726a939727ff816a614d241b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ac3b0e731726a939727ff816a614d241b">send</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:ac3b0e731726a939727ff816a614d241b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a single value via a blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#ac3b0e731726a939727ff816a614d241b">More...</a><br /></td></tr>
<tr class="separator:ac3b0e731726a939727ff816a614d241b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990f2e09f7d92480615e90cc16457316"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a990f2e09f7d92480615e90cc16457316"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a990f2e09f7d92480615e90cc16457316">send</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a990f2e09f7d92480615e90cc16457316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values having a specific memory layout via a blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a990f2e09f7d92480615e90cc16457316">More...</a><br /></td></tr>
<tr class="separator:a990f2e09f7d92480615e90cc16457316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2830d8cf5f8e9b162e899cf54f07bca9"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a2830d8cf5f8e9b162e899cf54f07bca9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a2830d8cf5f8e9b162e899cf54f07bca9">send</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a2830d8cf5f8e9b162e899cf54f07bca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a2830d8cf5f8e9b162e899cf54f07bca9">More...</a><br /></td></tr>
<tr class="separator:a2830d8cf5f8e9b162e899cf54f07bca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa32e597243c8e8870f1a9bc4775862f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa32e597243c8e8870f1a9bc4775862f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aaa32e597243c8e8870f1a9bc4775862f">isend</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:aaa32e597243c8e8870f1a9bc4775862f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a single value via a non-blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#aaa32e597243c8e8870f1a9bc4775862f">More...</a><br /></td></tr>
<tr class="separator:aaa32e597243c8e8870f1a9bc4775862f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713d1e82c0fd9e9c02404fb20dd9115f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a713d1e82c0fd9e9c02404fb20dd9115f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a713d1e82c0fd9e9c02404fb20dd9115f">isend</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a713d1e82c0fd9e9c02404fb20dd9115f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with several values having a specific memory layout via a non-blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a713d1e82c0fd9e9c02404fb20dd9115f">More...</a><br /></td></tr>
<tr class="separator:a713d1e82c0fd9e9c02404fb20dd9115f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d346b0d6e9065f390b9aff3b91b874"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a03d346b0d6e9065f390b9aff3b91b874"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a03d346b0d6e9065f390b9aff3b91b874">isend</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a03d346b0d6e9065f390b9aff3b91b874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a non-blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a03d346b0d6e9065f390b9aff3b91b874">More...</a><br /></td></tr>
<tr class="separator:a03d346b0d6e9065f390b9aff3b91b874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7982f8625c5078750d1fa544b11fb9bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7982f8625c5078750d1fa544b11fb9bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a7982f8625c5078750d1fa544b11fb9bf">send_init</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a7982f8625c5078750d1fa544b11fb9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a single value via a blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a7982f8625c5078750d1fa544b11fb9bf">More...</a><br /></td></tr>
<tr class="separator:a7982f8625c5078750d1fa544b11fb9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af8b0ee87ebfade234ff3f885cb1799"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8af8b0ee87ebfade234ff3f885cb1799"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a8af8b0ee87ebfade234ff3f885cb1799">send_init</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a8af8b0ee87ebfade234ff3f885cb1799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values having a specific memory layout via a blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a8af8b0ee87ebfade234ff3f885cb1799">More...</a><br /></td></tr>
<tr class="separator:a8af8b0ee87ebfade234ff3f885cb1799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914d0001e76d3f0b12b16bf7f4e6aceb"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a914d0001e76d3f0b12b16bf7f4e6aceb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a914d0001e76d3f0b12b16bf7f4e6aceb">send_init</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a914d0001e76d3f0b12b16bf7f4e6aceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values given by a pair of iterators via a blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a914d0001e76d3f0b12b16bf7f4e6aceb">More...</a><br /></td></tr>
<tr class="separator:a914d0001e76d3f0b12b16bf7f4e6aceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbb41cb9c5945966bda543ef82a16a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2cbb41cb9c5945966bda543ef82a16a5"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a2cbb41cb9c5945966bda543ef82a16a5">bsend_size</a> (int number=1) const</td></tr>
<tr class="memdesc:a2cbb41cb9c5945966bda543ef82a16a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the message buffer size.  <a href="classmpl_1_1impl_1_1base__communicator.html#a2cbb41cb9c5945966bda543ef82a16a5">More...</a><br /></td></tr>
<tr class="separator:a2cbb41cb9c5945966bda543ef82a16a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cf69c80f9698d438dd6623f0b3bbb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44cf69c80f9698d438dd6623f0b3bbb0"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a44cf69c80f9698d438dd6623f0b3bbb0">bsend_size</a> (const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int number=1) const</td></tr>
<tr class="memdesc:a44cf69c80f9698d438dd6623f0b3bbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the message buffer size.  <a href="classmpl_1_1impl_1_1base__communicator.html#a44cf69c80f9698d438dd6623f0b3bbb0">More...</a><br /></td></tr>
<tr class="separator:a44cf69c80f9698d438dd6623f0b3bbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2de6caeb0acc8f8398892f4b4b1a2cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2de6caeb0acc8f8398892f4b4b1a2cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#af2de6caeb0acc8f8398892f4b4b1a2cd">bsend</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:af2de6caeb0acc8f8398892f4b4b1a2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a single value via a buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#af2de6caeb0acc8f8398892f4b4b1a2cd">More...</a><br /></td></tr>
<tr class="separator:af2de6caeb0acc8f8398892f4b4b1a2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff7f9049631874e960562ac474abdc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ff7f9049631874e960562ac474abdc0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a9ff7f9049631874e960562ac474abdc0">bsend</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a9ff7f9049631874e960562ac474abdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values having a specific memory layout via a buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a9ff7f9049631874e960562ac474abdc0">More...</a><br /></td></tr>
<tr class="separator:a9ff7f9049631874e960562ac474abdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5d81a319710f9a0ce253dd7bee06f9"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:aab5d81a319710f9a0ce253dd7bee06f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aab5d81a319710f9a0ce253dd7bee06f9">bsend</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:aab5d81a319710f9a0ce253dd7bee06f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#aab5d81a319710f9a0ce253dd7bee06f9">More...</a><br /></td></tr>
<tr class="separator:aab5d81a319710f9a0ce253dd7bee06f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b89a2050b73fce16138c4fda3f7872d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b89a2050b73fce16138c4fda3f7872d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a8b89a2050b73fce16138c4fda3f7872d">ibsend</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a8b89a2050b73fce16138c4fda3f7872d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a single value via a non-blocking buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a8b89a2050b73fce16138c4fda3f7872d">More...</a><br /></td></tr>
<tr class="separator:a8b89a2050b73fce16138c4fda3f7872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf3f4909faf1036124b1247079b6af6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedf3f4909faf1036124b1247079b6af6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aedf3f4909faf1036124b1247079b6af6">ibsend</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:aedf3f4909faf1036124b1247079b6af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with several values having a specific memory layout via a non-blocking buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#aedf3f4909faf1036124b1247079b6af6">More...</a><br /></td></tr>
<tr class="separator:aedf3f4909faf1036124b1247079b6af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad915ee85eb905b4edaa2ade85ec4cc58"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:ad915ee85eb905b4edaa2ade85ec4cc58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ad915ee85eb905b4edaa2ade85ec4cc58">ibsend</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:ad915ee85eb905b4edaa2ade85ec4cc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a non-blocking buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#ad915ee85eb905b4edaa2ade85ec4cc58">More...</a><br /></td></tr>
<tr class="separator:ad915ee85eb905b4edaa2ade85ec4cc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45183e7f974388046dbe61f6dbc05e61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45183e7f974388046dbe61f6dbc05e61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a45183e7f974388046dbe61f6dbc05e61">bsend_init</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a45183e7f974388046dbe61f6dbc05e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a single value via a buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a45183e7f974388046dbe61f6dbc05e61">More...</a><br /></td></tr>
<tr class="separator:a45183e7f974388046dbe61f6dbc05e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc74ae1c4006da62a17197e5854eb6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdc74ae1c4006da62a17197e5854eb6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#acdc74ae1c4006da62a17197e5854eb6f">bsend_init</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:acdc74ae1c4006da62a17197e5854eb6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values having a specific memory layout via a buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#acdc74ae1c4006da62a17197e5854eb6f">More...</a><br /></td></tr>
<tr class="separator:acdc74ae1c4006da62a17197e5854eb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923344b718948986f2fca9b8efbcf012"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a923344b718948986f2fca9b8efbcf012"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a923344b718948986f2fca9b8efbcf012">bsend_init</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a923344b718948986f2fca9b8efbcf012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values given by a pair of iterators via a buffered send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a923344b718948986f2fca9b8efbcf012">More...</a><br /></td></tr>
<tr class="separator:a923344b718948986f2fca9b8efbcf012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63be7ddf6ff0ffa1030ff353e05acc79"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a63be7ddf6ff0ffa1030ff353e05acc79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a63be7ddf6ff0ffa1030ff353e05acc79">ssend</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a63be7ddf6ff0ffa1030ff353e05acc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a single value via a blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a63be7ddf6ff0ffa1030ff353e05acc79">More...</a><br /></td></tr>
<tr class="separator:a63be7ddf6ff0ffa1030ff353e05acc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842c446804617b143a71c6f4158f6cd9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a842c446804617b143a71c6f4158f6cd9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a842c446804617b143a71c6f4158f6cd9">ssend</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a842c446804617b143a71c6f4158f6cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values having a specific memory layout via a blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a842c446804617b143a71c6f4158f6cd9">More...</a><br /></td></tr>
<tr class="separator:a842c446804617b143a71c6f4158f6cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862ca31669e1d87b2a1c21dedc8e8cbc"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a862ca31669e1d87b2a1c21dedc8e8cbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a862ca31669e1d87b2a1c21dedc8e8cbc">ssend</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a862ca31669e1d87b2a1c21dedc8e8cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a862ca31669e1d87b2a1c21dedc8e8cbc">More...</a><br /></td></tr>
<tr class="separator:a862ca31669e1d87b2a1c21dedc8e8cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a1310602028a6fec86b60d64512cd5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9a1310602028a6fec86b60d64512cd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#af9a1310602028a6fec86b60d64512cd5">issend</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:af9a1310602028a6fec86b60d64512cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a single value via a non-blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#af9a1310602028a6fec86b60d64512cd5">More...</a><br /></td></tr>
<tr class="separator:af9a1310602028a6fec86b60d64512cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776edf9d2788906192267af47bf74d07"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a776edf9d2788906192267af47bf74d07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a776edf9d2788906192267af47bf74d07">issend</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a776edf9d2788906192267af47bf74d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with several values having a specific memory layout via a non-blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a776edf9d2788906192267af47bf74d07">More...</a><br /></td></tr>
<tr class="separator:a776edf9d2788906192267af47bf74d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f530043606d88ca7f321c6c4c7c14ef"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a2f530043606d88ca7f321c6c4c7c14ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a2f530043606d88ca7f321c6c4c7c14ef">issend</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a2f530043606d88ca7f321c6c4c7c14ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a non-blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a2f530043606d88ca7f321c6c4c7c14ef">More...</a><br /></td></tr>
<tr class="separator:a2f530043606d88ca7f321c6c4c7c14ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd73358c63baca47dc8807c4a2ee2b65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd73358c63baca47dc8807c4a2ee2b65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#abd73358c63baca47dc8807c4a2ee2b65">ssend_init</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:abd73358c63baca47dc8807c4a2ee2b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a single value via a blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#abd73358c63baca47dc8807c4a2ee2b65">More...</a><br /></td></tr>
<tr class="separator:abd73358c63baca47dc8807c4a2ee2b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7c5d8b854ecb53490d905bf9f69053"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a7c5d8b854ecb53490d905bf9f69053"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a7a7c5d8b854ecb53490d905bf9f69053">ssend_init</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a7a7c5d8b854ecb53490d905bf9f69053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values having a specific memory layout via a blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a7a7c5d8b854ecb53490d905bf9f69053">More...</a><br /></td></tr>
<tr class="separator:a7a7c5d8b854ecb53490d905bf9f69053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07640680936f14f3ace0d1d7539f3b19"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a07640680936f14f3ace0d1d7539f3b19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a07640680936f14f3ace0d1d7539f3b19">ssend_init</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a07640680936f14f3ace0d1d7539f3b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values given by a pair of iterators via a blocking synchronous send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a07640680936f14f3ace0d1d7539f3b19">More...</a><br /></td></tr>
<tr class="separator:a07640680936f14f3ace0d1d7539f3b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b00ddafa6438961cd3e05ce22a96afb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b00ddafa6438961cd3e05ce22a96afb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a5b00ddafa6438961cd3e05ce22a96afb">rsend</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a5b00ddafa6438961cd3e05ce22a96afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a single value via a blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a5b00ddafa6438961cd3e05ce22a96afb">More...</a><br /></td></tr>
<tr class="separator:a5b00ddafa6438961cd3e05ce22a96afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257bd4af8e5d09ef8967e32144693b1b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a257bd4af8e5d09ef8967e32144693b1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a257bd4af8e5d09ef8967e32144693b1b">rsend</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a257bd4af8e5d09ef8967e32144693b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values having a specific memory layout via a blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a257bd4af8e5d09ef8967e32144693b1b">More...</a><br /></td></tr>
<tr class="separator:a257bd4af8e5d09ef8967e32144693b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995f7850daaf8ea3347dd942af00db8f"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a995f7850daaf8ea3347dd942af00db8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a995f7850daaf8ea3347dd942af00db8f">rsend</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a995f7850daaf8ea3347dd942af00db8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a995f7850daaf8ea3347dd942af00db8f">More...</a><br /></td></tr>
<tr class="separator:a995f7850daaf8ea3347dd942af00db8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60dca19f3de7c889ebc4ede59f6e410"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af60dca19f3de7c889ebc4ede59f6e410"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#af60dca19f3de7c889ebc4ede59f6e410">irsend</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:af60dca19f3de7c889ebc4ede59f6e410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a single value via a non-blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#af60dca19f3de7c889ebc4ede59f6e410">More...</a><br /></td></tr>
<tr class="separator:af60dca19f3de7c889ebc4ede59f6e410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32a00947a95e27e857a48e6f8b83e05"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af32a00947a95e27e857a48e6f8b83e05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#af32a00947a95e27e857a48e6f8b83e05">irsend</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:af32a00947a95e27e857a48e6f8b83e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with several values having a specific memory layout via a non-blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#af32a00947a95e27e857a48e6f8b83e05">More...</a><br /></td></tr>
<tr class="separator:af32a00947a95e27e857a48e6f8b83e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1f39a3a24a7dccd0dfd5f9d6010757"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a8e1f39a3a24a7dccd0dfd5f9d6010757"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a8e1f39a3a24a7dccd0dfd5f9d6010757">irsend</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a8e1f39a3a24a7dccd0dfd5f9d6010757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with a several values given by a pair of iterators via a non-blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a8e1f39a3a24a7dccd0dfd5f9d6010757">More...</a><br /></td></tr>
<tr class="separator:a8e1f39a3a24a7dccd0dfd5f9d6010757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b00350327fd0656ddd4420f3c41176a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b00350327fd0656ddd4420f3c41176a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a9b00350327fd0656ddd4420f3c41176a">rsend_init</a> (const T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a9b00350327fd0656ddd4420f3c41176a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a single value via a blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a9b00350327fd0656ddd4420f3c41176a">More...</a><br /></td></tr>
<tr class="separator:a9b00350327fd0656ddd4420f3c41176a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ed4b2b4436f29466c1bab7164b37b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46ed4b2b4436f29466c1bab7164b37b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a46ed4b2b4436f29466c1bab7164b37b7">rsend_init</a> (const T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a46ed4b2b4436f29466c1bab7164b37b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values having a specific memory layout via a blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a46ed4b2b4436f29466c1bab7164b37b7">More...</a><br /></td></tr>
<tr class="separator:a46ed4b2b4436f29466c1bab7164b37b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fc8191506235854c21335e59e3de67"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:aa2fc8191506235854c21335e59e3de67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aa2fc8191506235854c21335e59e3de67">rsend_init</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:aa2fc8191506235854c21335e59e3de67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to send a message with a several values given by a pair of iterators via a blocking ready send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#aa2fc8191506235854c21335e59e3de67">More...</a><br /></td></tr>
<tr class="separator:aa2fc8191506235854c21335e59e3de67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed451f2d5ea46348a1e4ca1ecd84ee8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ed451f2d5ea46348a1e4ca1ecd84ee8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a8ed451f2d5ea46348a1e4ca1ecd84ee8">recv</a> (T &amp;data, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a8ed451f2d5ea46348a1e4ca1ecd84ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a single value.  <a href="classmpl_1_1impl_1_1base__communicator.html#a8ed451f2d5ea46348a1e4ca1ecd84ee8">More...</a><br /></td></tr>
<tr class="separator:a8ed451f2d5ea46348a1e4ca1ecd84ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cce3b6810686d34edb81b0fcf6d7874"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5cce3b6810686d34edb81b0fcf6d7874"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a5cce3b6810686d34edb81b0fcf6d7874">recv</a> (T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a5cce3b6810686d34edb81b0fcf6d7874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a several values having a specific memory layout.  <a href="classmpl_1_1impl_1_1base__communicator.html#a5cce3b6810686d34edb81b0fcf6d7874">More...</a><br /></td></tr>
<tr class="separator:a5cce3b6810686d34edb81b0fcf6d7874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41379e1fb24e1a2bd826f8168d65be74"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a41379e1fb24e1a2bd826f8168d65be74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a41379e1fb24e1a2bd826f8168d65be74">recv</a> (iterT begin, iterT end, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a41379e1fb24e1a2bd826f8168d65be74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a several values given by a pair of iterators.  <a href="classmpl_1_1impl_1_1base__communicator.html#a41379e1fb24e1a2bd826f8168d65be74">More...</a><br /></td></tr>
<tr class="separator:a41379e1fb24e1a2bd826f8168d65be74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bca7804e7a466fff401a8aa823f292"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2bca7804e7a466fff401a8aa823f292"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ab2bca7804e7a466fff401a8aa823f292">irecv</a> (T &amp;data, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:ab2bca7804e7a466fff401a8aa823f292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a single value via a non-blocking receive operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#ab2bca7804e7a466fff401a8aa823f292">More...</a><br /></td></tr>
<tr class="separator:ab2bca7804e7a466fff401a8aa823f292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f8ca1551c24cce5b98ae1531c63892"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11f8ca1551c24cce5b98ae1531c63892"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a11f8ca1551c24cce5b98ae1531c63892">irecv</a> (T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a11f8ca1551c24cce5b98ae1531c63892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with several values having a specific memory layout via a non-blocking receive operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a11f8ca1551c24cce5b98ae1531c63892">More...</a><br /></td></tr>
<tr class="separator:a11f8ca1551c24cce5b98ae1531c63892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2f8c410dadb02c2247b76c94a38dc4"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a9a2f8c410dadb02c2247b76c94a38dc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a9a2f8c410dadb02c2247b76c94a38dc4">irecv</a> (iterT begin, iterT end, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a9a2f8c410dadb02c2247b76c94a38dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a several values given by a pair of iterators via a non-blocking receive operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a9a2f8c410dadb02c2247b76c94a38dc4">More...</a><br /></td></tr>
<tr class="separator:a9a2f8c410dadb02c2247b76c94a38dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b9722648c47d6751a5195cfbf49e9d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a33b9722648c47d6751a5195cfbf49e9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a33b9722648c47d6751a5195cfbf49e9d">recv_init</a> (T &amp;data, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a33b9722648c47d6751a5195cfbf49e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to receive a message with a single value via a blocking receive operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a33b9722648c47d6751a5195cfbf49e9d">More...</a><br /></td></tr>
<tr class="separator:a33b9722648c47d6751a5195cfbf49e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49140cee541e8ade8a21b724ddeb189"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac49140cee541e8ade8a21b724ddeb189"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ac49140cee541e8ade8a21b724ddeb189">recv_init</a> (T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:ac49140cee541e8ade8a21b724ddeb189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to receive a message with a several values having a specific memory layout via a blocking standard send operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#ac49140cee541e8ade8a21b724ddeb189">More...</a><br /></td></tr>
<tr class="separator:ac49140cee541e8ade8a21b724ddeb189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5fba6ec72344fcfb29e31907b2ff15"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a2a5fba6ec72344fcfb29e31907b2ff15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1prequest.html">prequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a2a5fba6ec72344fcfb29e31907b2ff15">recv_init</a> (iterT begin, iterT end, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a2a5fba6ec72344fcfb29e31907b2ff15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a persistent communication request to receive a message with a several values given by a pair of iterators via a blocking receive operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a2a5fba6ec72344fcfb29e31907b2ff15">More...</a><br /></td></tr>
<tr class="separator:a2a5fba6ec72344fcfb29e31907b2ff15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed051ae1ad9ea893018ee0b1d98b9ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a8ed051ae1ad9ea893018ee0b1d98b9ec">probe</a> (int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a8ed051ae1ad9ea893018ee0b1d98b9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking test for an incoming message.  <a href="classmpl_1_1impl_1_1base__communicator.html#a8ed051ae1ad9ea893018ee0b1d98b9ec">More...</a><br /></td></tr>
<tr class="separator:a8ed051ae1ad9ea893018ee0b1d98b9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e99359be32a4d45501830f900284a06"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmpl_1_1status__t.html">status_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a5e99359be32a4d45501830f900284a06">iprobe</a> (int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a5e99359be32a4d45501830f900284a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking test for an incoming message.  <a href="classmpl_1_1impl_1_1base__communicator.html#a5e99359be32a4d45501830f900284a06">More...</a><br /></td></tr>
<tr class="separator:a5e99359be32a4d45501830f900284a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058e89e1168eed5f1c1045160d299321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmpl_1_1mprobe__status.html">mprobe_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a058e89e1168eed5f1c1045160d299321">mprobe</a> (int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a058e89e1168eed5f1c1045160d299321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking matched test for an incoming message.  <a href="classmpl_1_1impl_1_1base__communicator.html#a058e89e1168eed5f1c1045160d299321">More...</a><br /></td></tr>
<tr class="separator:a058e89e1168eed5f1c1045160d299321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec9bf459e52d421c99686aa1efaea6a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structmpl_1_1mprobe__status.html">mprobe_status</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a0ec9bf459e52d421c99686aa1efaea6a">improbe</a> (int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> t=<a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)) const</td></tr>
<tr class="memdesc:a0ec9bf459e52d421c99686aa1efaea6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking matched test for an incoming message.  <a href="classmpl_1_1impl_1_1base__communicator.html#a0ec9bf459e52d421c99686aa1efaea6a">More...</a><br /></td></tr>
<tr class="separator:a0ec9bf459e52d421c99686aa1efaea6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682010694b06d271f397f4e682ff8ef8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a682010694b06d271f397f4e682ff8ef8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a682010694b06d271f397f4e682ff8ef8">mrecv</a> (T &amp;data, <a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;m) const</td></tr>
<tr class="memdesc:a682010694b06d271f397f4e682ff8ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a single value by a message handle.  <a href="classmpl_1_1impl_1_1base__communicator.html#a682010694b06d271f397f4e682ff8ef8">More...</a><br /></td></tr>
<tr class="separator:a682010694b06d271f397f4e682ff8ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac183e6477f6cc04fa46248de4b4b6eed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac183e6477f6cc04fa46248de4b4b6eed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ac183e6477f6cc04fa46248de4b4b6eed">mrecv</a> (T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, <a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;m) const</td></tr>
<tr class="memdesc:ac183e6477f6cc04fa46248de4b4b6eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a several values having a specific memory layout by a message handle.  <a href="classmpl_1_1impl_1_1base__communicator.html#ac183e6477f6cc04fa46248de4b4b6eed">More...</a><br /></td></tr>
<tr class="separator:ac183e6477f6cc04fa46248de4b4b6eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33937f5473f2424ed10aff8d723b8ca3"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a33937f5473f2424ed10aff8d723b8ca3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a33937f5473f2424ed10aff8d723b8ca3">mrecv</a> (iterT begin, iterT end, <a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;m) const</td></tr>
<tr class="memdesc:a33937f5473f2424ed10aff8d723b8ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a several values given by a pair of iterators by a message handle.  <a href="classmpl_1_1impl_1_1base__communicator.html#a33937f5473f2424ed10aff8d723b8ca3">More...</a><br /></td></tr>
<tr class="separator:a33937f5473f2424ed10aff8d723b8ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c42ccf3d4fa5b826970d51c3ceb37ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0c42ccf3d4fa5b826970d51c3ceb37ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a0c42ccf3d4fa5b826970d51c3ceb37ae">imrecv</a> (T &amp;data, <a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;m) const</td></tr>
<tr class="memdesc:a0c42ccf3d4fa5b826970d51c3ceb37ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a single value via a non-blocking receive operation by a message handle.  <a href="classmpl_1_1impl_1_1base__communicator.html#a0c42ccf3d4fa5b826970d51c3ceb37ae">More...</a><br /></td></tr>
<tr class="separator:a0c42ccf3d4fa5b826970d51c3ceb37ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a829a6fb9fb725f35dfa84b4fee55f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a55a829a6fb9fb725f35dfa84b4fee55f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a55a829a6fb9fb725f35dfa84b4fee55f">imrecv</a> (T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, <a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;m) const</td></tr>
<tr class="memdesc:a55a829a6fb9fb725f35dfa84b4fee55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with several values having a specific memory layout via a non-blocking receive operation by a message handle.  <a href="classmpl_1_1impl_1_1base__communicator.html#a55a829a6fb9fb725f35dfa84b4fee55f">More...</a><br /></td></tr>
<tr class="separator:a55a829a6fb9fb725f35dfa84b4fee55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad22c8b3483384b4f141cf5721f4b40"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:a6ad22c8b3483384b4f141cf5721f4b40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a6ad22c8b3483384b4f141cf5721f4b40">imrecv</a> (iterT begin, iterT end, <a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;m) const</td></tr>
<tr class="memdesc:a6ad22c8b3483384b4f141cf5721f4b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message with a several values given by a pair of iterators via a non-blocking receive operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a6ad22c8b3483384b4f141cf5721f4b40">More...</a><br /></td></tr>
<tr class="separator:a6ad22c8b3483384b4f141cf5721f4b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84985acac072b195e21cfd2b69220ab8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a84985acac072b195e21cfd2b69220ab8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a84985acac072b195e21cfd2b69220ab8">sendrecv</a> (const T &amp;senddata, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> sendtag, T &amp;recvdata, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> recvtag) const</td></tr>
<tr class="memdesc:a84985acac072b195e21cfd2b69220ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message and receives a message in a single operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a84985acac072b195e21cfd2b69220ab8">More...</a><br /></td></tr>
<tr class="separator:a84985acac072b195e21cfd2b69220ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cc26da5ac38e24691752bfcd7d9c26"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2cc26da5ac38e24691752bfcd7d9c26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#af2cc26da5ac38e24691752bfcd7d9c26">sendrecv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> sendtag, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> recvtag) const</td></tr>
<tr class="memdesc:af2cc26da5ac38e24691752bfcd7d9c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message and receives a message in a single operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#af2cc26da5ac38e24691752bfcd7d9c26">More...</a><br /></td></tr>
<tr class="separator:af2cc26da5ac38e24691752bfcd7d9c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83aac396a46f8b7287225b6b404c6789"><td class="memTemplParams" colspan="2">template&lt;typename iterT1 , typename iterT2 &gt; </td></tr>
<tr class="memitem:a83aac396a46f8b7287225b6b404c6789"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a83aac396a46f8b7287225b6b404c6789">sendrecv</a> (iterT1 begin1, iterT1 end1, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> sendtag, iterT2 begin2, iterT2 end2, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> recvtag) const</td></tr>
<tr class="memdesc:a83aac396a46f8b7287225b6b404c6789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message and receives a message in a single operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a83aac396a46f8b7287225b6b404c6789">More...</a><br /></td></tr>
<tr class="separator:a83aac396a46f8b7287225b6b404c6789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a713de3261c9b7667f754ac587ba6ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a713de3261c9b7667f754ac587ba6ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a6a713de3261c9b7667f754ac587ba6ce">sendrecv_replace</a> (T &amp;data, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> sendtag, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> recvtag) const</td></tr>
<tr class="memdesc:a6a713de3261c9b7667f754ac587ba6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message and receives a message in a single operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#a6a713de3261c9b7667f754ac587ba6ce">More...</a><br /></td></tr>
<tr class="separator:a6a713de3261c9b7667f754ac587ba6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac094726cff7f3be751bb3ab3cbc5b178"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac094726cff7f3be751bb3ab3cbc5b178"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ac094726cff7f3be751bb3ab3cbc5b178">sendrecv_replace</a> (T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> sendtag, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> recvtag) const</td></tr>
<tr class="memdesc:ac094726cff7f3be751bb3ab3cbc5b178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message and receives a message in a single operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#ac094726cff7f3be751bb3ab3cbc5b178">More...</a><br /></td></tr>
<tr class="separator:ac094726cff7f3be751bb3ab3cbc5b178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5779a5778f565ea5857cd5b7c7b3c4"><td class="memTemplParams" colspan="2">template&lt;typename iterT &gt; </td></tr>
<tr class="memitem:aca5779a5778f565ea5857cd5b7c7b3c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1status__t.html">status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aca5779a5778f565ea5857cd5b7c7b3c4">sendrecv_replace</a> (iterT begin, iterT end, int destination, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> sendtag, int source, <a class="el" href="classmpl_1_1tag__t.html">tag_t</a> recvtag) const</td></tr>
<tr class="memdesc:aca5779a5778f565ea5857cd5b7c7b3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message and receives a message in a single operation.  <a href="classmpl_1_1impl_1_1base__communicator.html#aca5779a5778f565ea5857cd5b7c7b3c4">More...</a><br /></td></tr>
<tr class="separator:aca5779a5778f565ea5857cd5b7c7b3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea2476951464fc6f12c3059d13b5bb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a4ea2476951464fc6f12c3059d13b5bb9">barrier</a> () const</td></tr>
<tr class="memdesc:a4ea2476951464fc6f12c3059d13b5bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until all processes in the communicator have reached this method.  <a href="classmpl_1_1impl_1_1base__communicator.html#a4ea2476951464fc6f12c3059d13b5bb9">More...</a><br /></td></tr>
<tr class="separator:a4ea2476951464fc6f12c3059d13b5bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa87e0859e0936b4c436757025e14cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aaa87e0859e0936b4c436757025e14cdd">ibarrier</a> () const</td></tr>
<tr class="memdesc:aaa87e0859e0936b4c436757025e14cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the process that it has reached the barrier and returns immediately.  <a href="classmpl_1_1impl_1_1base__communicator.html#aaa87e0859e0936b4c436757025e14cdd">More...</a><br /></td></tr>
<tr class="separator:aaa87e0859e0936b4c436757025e14cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7f1e51ab84e36fe669f630478a43be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c7f1e51ab84e36fe669f630478a43be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a8c7f1e51ab84e36fe669f630478a43be">bcast</a> (int root_rank, T &amp;data) const</td></tr>
<tr class="memdesc:a8c7f1e51ab84e36fe669f630478a43be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts a message from a process to all other processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a8c7f1e51ab84e36fe669f630478a43be">More...</a><br /></td></tr>
<tr class="separator:a8c7f1e51ab84e36fe669f630478a43be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2f6c2599fd0e04890eddfe02d9ae82"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec2f6c2599fd0e04890eddfe02d9ae82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aec2f6c2599fd0e04890eddfe02d9ae82">bcast</a> (int root_rank, T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:aec2f6c2599fd0e04890eddfe02d9ae82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts a message from a process to all other processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#aec2f6c2599fd0e04890eddfe02d9ae82">More...</a><br /></td></tr>
<tr class="separator:aec2f6c2599fd0e04890eddfe02d9ae82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f91ffcfc0640d8e493e60fd1ce4ce49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f91ffcfc0640d8e493e60fd1ce4ce49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a0f91ffcfc0640d8e493e60fd1ce4ce49">ibcast</a> (int root_rank, T &amp;data) const</td></tr>
<tr class="memdesc:a0f91ffcfc0640d8e493e60fd1ce4ce49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts a message from a process to all other processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a0f91ffcfc0640d8e493e60fd1ce4ce49">More...</a><br /></td></tr>
<tr class="separator:a0f91ffcfc0640d8e493e60fd1ce4ce49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa47dbaa764103a4992654373dc083c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa47dbaa764103a4992654373dc083c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aaa47dbaa764103a4992654373dc083c9">ibcast</a> (int root_rank, T *data, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;l) const</td></tr>
<tr class="memdesc:aaa47dbaa764103a4992654373dc083c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts a message from a process to all other processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#aaa47dbaa764103a4992654373dc083c9">More...</a><br /></td></tr>
<tr class="separator:aaa47dbaa764103a4992654373dc083c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb69ffd367e57984c967122b4a2f97fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb69ffd367e57984c967122b4a2f97fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#acb69ffd367e57984c967122b4a2f97fe">gather</a> (int root_rank, const T &amp;senddata, T *recvdata) const</td></tr>
<tr class="memdesc:acb69ffd367e57984c967122b4a2f97fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process.  <a href="classmpl_1_1impl_1_1base__communicator.html#acb69ffd367e57984c967122b4a2f97fe">More...</a><br /></td></tr>
<tr class="separator:acb69ffd367e57984c967122b4a2f97fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b4d15457ea636b95e549fbb5aec6e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97b4d15457ea636b95e549fbb5aec6e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a97b4d15457ea636b95e549fbb5aec6e7">gather</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a97b4d15457ea636b95e549fbb5aec6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process.  <a href="classmpl_1_1impl_1_1base__communicator.html#a97b4d15457ea636b95e549fbb5aec6e7">More...</a><br /></td></tr>
<tr class="separator:a97b4d15457ea636b95e549fbb5aec6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eb16ddb0c7a7a6c942fa97eef2dc24"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39eb16ddb0c7a7a6c942fa97eef2dc24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a39eb16ddb0c7a7a6c942fa97eef2dc24">gather</a> (int root_rank, const T &amp;senddata) const</td></tr>
<tr class="memdesc:a39eb16ddb0c7a7a6c942fa97eef2dc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process.  <a href="classmpl_1_1impl_1_1base__communicator.html#a39eb16ddb0c7a7a6c942fa97eef2dc24">More...</a><br /></td></tr>
<tr class="separator:a39eb16ddb0c7a7a6c942fa97eef2dc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6b9dc95c95ef4bcb939f4b9d5b9f18"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa6b9dc95c95ef4bcb939f4b9d5b9f18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#afa6b9dc95c95ef4bcb939f4b9d5b9f18">gather</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl) const</td></tr>
<tr class="memdesc:afa6b9dc95c95ef4bcb939f4b9d5b9f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process.  <a href="classmpl_1_1impl_1_1base__communicator.html#afa6b9dc95c95ef4bcb939f4b9d5b9f18">More...</a><br /></td></tr>
<tr class="separator:afa6b9dc95c95ef4bcb939f4b9d5b9f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52b0fb0f22cdb5fbcd6947c14841baa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae52b0fb0f22cdb5fbcd6947c14841baa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ae52b0fb0f22cdb5fbcd6947c14841baa">igather</a> (int root_rank, const T &amp;senddata, T *recvdata) const</td></tr>
<tr class="memdesc:ae52b0fb0f22cdb5fbcd6947c14841baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#ae52b0fb0f22cdb5fbcd6947c14841baa">More...</a><br /></td></tr>
<tr class="separator:ae52b0fb0f22cdb5fbcd6947c14841baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ceeaff35297ef5c90df1a24ae28ed9d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ceeaff35297ef5c90df1a24ae28ed9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a3ceeaff35297ef5c90df1a24ae28ed9d">igather</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a3ceeaff35297ef5c90df1a24ae28ed9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a3ceeaff35297ef5c90df1a24ae28ed9d">More...</a><br /></td></tr>
<tr class="separator:a3ceeaff35297ef5c90df1a24ae28ed9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f523b45eac440adecaab3f7a07cd43"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7f523b45eac440adecaab3f7a07cd43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ac7f523b45eac440adecaab3f7a07cd43">igather</a> (int root_rank, const T &amp;senddata) const</td></tr>
<tr class="memdesc:ac7f523b45eac440adecaab3f7a07cd43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#ac7f523b45eac440adecaab3f7a07cd43">More...</a><br /></td></tr>
<tr class="separator:ac7f523b45eac440adecaab3f7a07cd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84772592ff24d7a2d0086ad0e3fe9fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa84772592ff24d7a2d0086ad0e3fe9fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aa84772592ff24d7a2d0086ad0e3fe9fb">igather</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl) const</td></tr>
<tr class="memdesc:aa84772592ff24d7a2d0086ad0e3fe9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes at a single root process in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#aa84772592ff24d7a2d0086ad0e3fe9fb">More...</a><br /></td></tr>
<tr class="separator:aa84772592ff24d7a2d0086ad0e3fe9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991f687ee554c4a76ff920b6935ef407"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a991f687ee554c4a76ff920b6935ef407"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a991f687ee554c4a76ff920b6935ef407">gatherv</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:a991f687ee554c4a76ff920b6935ef407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes at a single root process.  <a href="classmpl_1_1impl_1_1base__communicator.html#a991f687ee554c4a76ff920b6935ef407">More...</a><br /></td></tr>
<tr class="separator:a991f687ee554c4a76ff920b6935ef407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29e5b6744d628dea82c7dba0079ddc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad29e5b6744d628dea82c7dba0079ddc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ad29e5b6744d628dea82c7dba0079ddc4">gatherv</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:ad29e5b6744d628dea82c7dba0079ddc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes at a single root process.  <a href="classmpl_1_1impl_1_1base__communicator.html#ad29e5b6744d628dea82c7dba0079ddc4">More...</a><br /></td></tr>
<tr class="separator:ad29e5b6744d628dea82c7dba0079ddc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff55b7fd641226e881ed6c8e4fd69b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ff55b7fd641226e881ed6c8e4fd69b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a8ff55b7fd641226e881ed6c8e4fd69b3">gatherv</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl) const</td></tr>
<tr class="memdesc:a8ff55b7fd641226e881ed6c8e4fd69b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes at a single root process.  <a href="classmpl_1_1impl_1_1base__communicator.html#a8ff55b7fd641226e881ed6c8e4fd69b3">More...</a><br /></td></tr>
<tr class="separator:a8ff55b7fd641226e881ed6c8e4fd69b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcc5b4f2087a49ed620a170165217d9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafcc5b4f2087a49ed620a170165217d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aafcc5b4f2087a49ed620a170165217d9">igatherv</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:aafcc5b4f2087a49ed620a170165217d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes at a single root process in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#aafcc5b4f2087a49ed620a170165217d9">More...</a><br /></td></tr>
<tr class="separator:aafcc5b4f2087a49ed620a170165217d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d4e6d9f819b35ab72606728b9f5e99"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82d4e6d9f819b35ab72606728b9f5e99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a82d4e6d9f819b35ab72606728b9f5e99">igatherv</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:a82d4e6d9f819b35ab72606728b9f5e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes at a single root process in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a82d4e6d9f819b35ab72606728b9f5e99">More...</a><br /></td></tr>
<tr class="separator:a82d4e6d9f819b35ab72606728b9f5e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1823308d45ebd071938597345ddc6f45"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1823308d45ebd071938597345ddc6f45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a1823308d45ebd071938597345ddc6f45">igatherv</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl) const</td></tr>
<tr class="memdesc:a1823308d45ebd071938597345ddc6f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes at a single root process in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a1823308d45ebd071938597345ddc6f45">More...</a><br /></td></tr>
<tr class="separator:a1823308d45ebd071938597345ddc6f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd0c45df8daca2f36291951effb8153"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abcd0c45df8daca2f36291951effb8153"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#abcd0c45df8daca2f36291951effb8153">allgather</a> (const T &amp;senddata, T *recvdata) const</td></tr>
<tr class="memdesc:abcd0c45df8daca2f36291951effb8153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes and distribute result to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#abcd0c45df8daca2f36291951effb8153">More...</a><br /></td></tr>
<tr class="separator:abcd0c45df8daca2f36291951effb8153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77e03595a19600fcc37cc46056bcf3d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac77e03595a19600fcc37cc46056bcf3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ac77e03595a19600fcc37cc46056bcf3d">allgather</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:ac77e03595a19600fcc37cc46056bcf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes and distribute result to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#ac77e03595a19600fcc37cc46056bcf3d">More...</a><br /></td></tr>
<tr class="separator:ac77e03595a19600fcc37cc46056bcf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4576dc948f8caf806b18dab1741150"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d4576dc948f8caf806b18dab1741150"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a5d4576dc948f8caf806b18dab1741150">iallgather</a> (const T &amp;senddata, T *recvdata) const</td></tr>
<tr class="memdesc:a5d4576dc948f8caf806b18dab1741150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes and distribute result to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a5d4576dc948f8caf806b18dab1741150">More...</a><br /></td></tr>
<tr class="separator:a5d4576dc948f8caf806b18dab1741150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663729ac6fc2228d97cd6a731d7393ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a663729ac6fc2228d97cd6a731d7393ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a663729ac6fc2228d97cd6a731d7393ac">iallgather</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a663729ac6fc2228d97cd6a731d7393ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages from all processes and distribute result to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a663729ac6fc2228d97cd6a731d7393ac">More...</a><br /></td></tr>
<tr class="separator:a663729ac6fc2228d97cd6a731d7393ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe706e36c83be1873aa6ee150b945e5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe706e36c83be1873aa6ee150b945e5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#abe706e36c83be1873aa6ee150b945e5a">allgatherv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:abe706e36c83be1873aa6ee150b945e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes and distribute result to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#abe706e36c83be1873aa6ee150b945e5a">More...</a><br /></td></tr>
<tr class="separator:abe706e36c83be1873aa6ee150b945e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e32e8519c9195e37e9aefb3370075c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29e32e8519c9195e37e9aefb3370075c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a29e32e8519c9195e37e9aefb3370075c">allgatherv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:a29e32e8519c9195e37e9aefb3370075c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes and distribute result to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a29e32e8519c9195e37e9aefb3370075c">More...</a><br /></td></tr>
<tr class="separator:a29e32e8519c9195e37e9aefb3370075c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa313a0f605d5da994a8a712ddcf791ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa313a0f605d5da994a8a712ddcf791ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aa313a0f605d5da994a8a712ddcf791ec">iallgatherv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;recvdispls) const</td></tr>
<tr class="memdesc:aa313a0f605d5da994a8a712ddcf791ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes and distribute result to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#aa313a0f605d5da994a8a712ddcf791ec">More...</a><br /></td></tr>
<tr class="separator:aa313a0f605d5da994a8a712ddcf791ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807a21d0db687f61528cd8dc0816e6c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a807a21d0db687f61528cd8dc0816e6c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a807a21d0db687f61528cd8dc0816e6c1">iallgatherv</a> (const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;recvls) const</td></tr>
<tr class="memdesc:a807a21d0db687f61528cd8dc0816e6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather messages with a variable amount of data from all processes and distribute result to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a807a21d0db687f61528cd8dc0816e6c1">More...</a><br /></td></tr>
<tr class="separator:a807a21d0db687f61528cd8dc0816e6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5076229b612f84540cb27b0bf81d114d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5076229b612f84540cb27b0bf81d114d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a5076229b612f84540cb27b0bf81d114d">scatter</a> (int root_rank, const T *senddata, T &amp;recvdata) const</td></tr>
<tr class="memdesc:a5076229b612f84540cb27b0bf81d114d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a5076229b612f84540cb27b0bf81d114d">More...</a><br /></td></tr>
<tr class="separator:a5076229b612f84540cb27b0bf81d114d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ccfd59e06701d3fdfb425dc1cba3ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24ccfd59e06701d3fdfb425dc1cba3ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a24ccfd59e06701d3fdfb425dc1cba3ad">scatter</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a24ccfd59e06701d3fdfb425dc1cba3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a24ccfd59e06701d3fdfb425dc1cba3ad">More...</a><br /></td></tr>
<tr class="separator:a24ccfd59e06701d3fdfb425dc1cba3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e66c5b2cc66e616896c1aeb5fc267b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a68e66c5b2cc66e616896c1aeb5fc267b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a68e66c5b2cc66e616896c1aeb5fc267b">scatter</a> (int root_rank, T &amp;recvdata) const</td></tr>
<tr class="memdesc:a68e66c5b2cc66e616896c1aeb5fc267b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a68e66c5b2cc66e616896c1aeb5fc267b">More...</a><br /></td></tr>
<tr class="separator:a68e66c5b2cc66e616896c1aeb5fc267b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbaa6c0a4206bd18084d9a4aeff407b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbaa6c0a4206bd18084d9a4aeff407b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#abbaa6c0a4206bd18084d9a4aeff407b3">scatter</a> (int root_rank, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:abbaa6c0a4206bd18084d9a4aeff407b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#abbaa6c0a4206bd18084d9a4aeff407b3">More...</a><br /></td></tr>
<tr class="separator:abbaa6c0a4206bd18084d9a4aeff407b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94de848c2ae1ba01778f6ce94fe9dd69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94de848c2ae1ba01778f6ce94fe9dd69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a94de848c2ae1ba01778f6ce94fe9dd69">iscatter</a> (int root_rank, const T *senddata, T &amp;recvdata) const</td></tr>
<tr class="memdesc:a94de848c2ae1ba01778f6ce94fe9dd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a94de848c2ae1ba01778f6ce94fe9dd69">More...</a><br /></td></tr>
<tr class="separator:a94de848c2ae1ba01778f6ce94fe9dd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0aee2dd234e053173e8aa2f6732356"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba0aee2dd234e053173e8aa2f6732356"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aba0aee2dd234e053173e8aa2f6732356">iscatter</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;sendl, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:aba0aee2dd234e053173e8aa2f6732356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#aba0aee2dd234e053173e8aa2f6732356">More...</a><br /></td></tr>
<tr class="separator:aba0aee2dd234e053173e8aa2f6732356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62be5f0ed07414914958715bd73ef14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae62be5f0ed07414914958715bd73ef14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ae62be5f0ed07414914958715bd73ef14">iscatter</a> (int root_rank, T &amp;recvdata) const</td></tr>
<tr class="memdesc:ae62be5f0ed07414914958715bd73ef14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#ae62be5f0ed07414914958715bd73ef14">More...</a><br /></td></tr>
<tr class="separator:ae62be5f0ed07414914958715bd73ef14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dbfd59415b14803d6489ac0280896c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3dbfd59415b14803d6489ac0280896c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#aa3dbfd59415b14803d6489ac0280896c">iscatter</a> (int root_rank, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:aa3dbfd59415b14803d6489ac0280896c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages from a single root process to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#aa3dbfd59415b14803d6489ac0280896c">More...</a><br /></td></tr>
<tr class="separator:aa3dbfd59415b14803d6489ac0280896c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bf73d794343073b39d65c699b5d143"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a04bf73d794343073b39d65c699b5d143"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a04bf73d794343073b39d65c699b5d143">scatterv</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;senddispls, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a04bf73d794343073b39d65c699b5d143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages with a variable amount of data from a single root process to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a04bf73d794343073b39d65c699b5d143">More...</a><br /></td></tr>
<tr class="separator:a04bf73d794343073b39d65c699b5d143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b766673f41b3bb395c4ee5eeb69358e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b766673f41b3bb395c4ee5eeb69358e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a9b766673f41b3bb395c4ee5eeb69358e">scatterv</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a9b766673f41b3bb395c4ee5eeb69358e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages with a variable amount of data from a single root process to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a9b766673f41b3bb395c4ee5eeb69358e">More...</a><br /></td></tr>
<tr class="separator:a9b766673f41b3bb395c4ee5eeb69358e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0f08cd1f0f2ed77ad06f636360aabc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e0f08cd1f0f2ed77ad06f636360aabc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a7e0f08cd1f0f2ed77ad06f636360aabc">scatterv</a> (int root_rank, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a7e0f08cd1f0f2ed77ad06f636360aabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages with a variable amount of data from a single root process to all processes.  <a href="classmpl_1_1impl_1_1base__communicator.html#a7e0f08cd1f0f2ed77ad06f636360aabc">More...</a><br /></td></tr>
<tr class="separator:a7e0f08cd1f0f2ed77ad06f636360aabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452c129fde4be77ba0322d9416fd2f53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a452c129fde4be77ba0322d9416fd2f53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a452c129fde4be77ba0322d9416fd2f53">iscatterv</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;senddispls, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a452c129fde4be77ba0322d9416fd2f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages with a variable amount of data from a single root process to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a452c129fde4be77ba0322d9416fd2f53">More...</a><br /></td></tr>
<tr class="separator:a452c129fde4be77ba0322d9416fd2f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66688a6aeec5d0e58662b9a7905ad62b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a66688a6aeec5d0e58662b9a7905ad62b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a66688a6aeec5d0e58662b9a7905ad62b">iscatterv</a> (int root_rank, const T *senddata, const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;sendls, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a66688a6aeec5d0e58662b9a7905ad62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages with a variable amount of data from a single root process to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a66688a6aeec5d0e58662b9a7905ad62b">More...</a><br /></td></tr>
<tr class="separator:a66688a6aeec5d0e58662b9a7905ad62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b13502e4102508decb2bcef35790e14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b13502e4102508decb2bcef35790e14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a4b13502e4102508decb2bcef35790e14">iscatterv</a> (int root_rank, T *recvdata, const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;recvl) const</td></tr>
<tr class="memdesc:a4b13502e4102508decb2bcef35790e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter messages with a variable amount of data from a single root process to all processes in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a4b13502e4102508decb2bcef35790e14">More...</a><br /></td></tr>
<tr class="separator:a4b13502e4102508decb2bcef35790e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8504097e2a5054c2411a23e515b8fb2f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a8504097e2a5054c2411a23e515b8fb2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a8504097e2a5054c2411a23e515b8fb2f">reduce_scatter_block</a> (F f, const T *senddata, T &amp;recvdata) const</td></tr>
<tr class="memdesc:a8504097e2a5054c2411a23e515b8fb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and scatters the result.  <a href="classmpl_1_1impl_1_1base__communicator.html#a8504097e2a5054c2411a23e515b8fb2f">More...</a><br /></td></tr>
<tr class="separator:a8504097e2a5054c2411a23e515b8fb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6770e234f2ed37f5bcabd76725d1c645"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a6770e234f2ed37f5bcabd76725d1c645"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a6770e234f2ed37f5bcabd76725d1c645">reduce_scatter_block</a> (F f, const T *senddata, T *recvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;recvcount) const</td></tr>
<tr class="memdesc:a6770e234f2ed37f5bcabd76725d1c645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and scatters the result.  <a href="classmpl_1_1impl_1_1base__communicator.html#a6770e234f2ed37f5bcabd76725d1c645">More...</a><br /></td></tr>
<tr class="separator:a6770e234f2ed37f5bcabd76725d1c645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091a848480618e4d15c28c4443f71d57"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a091a848480618e4d15c28c4443f71d57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a091a848480618e4d15c28c4443f71d57">ireduce_scatter_block</a> (F f, const T *senddata, T &amp;recvdata) const</td></tr>
<tr class="memdesc:a091a848480618e4d15c28c4443f71d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and scatters the result in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a091a848480618e4d15c28c4443f71d57">More...</a><br /></td></tr>
<tr class="separator:a091a848480618e4d15c28c4443f71d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ece54228622ed7124bd002e203f3652"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a5ece54228622ed7124bd002e203f3652"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a5ece54228622ed7124bd002e203f3652">ireduce_scatter_block</a> (F f, const T *senddata, T *recvdata, const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;recvcount) const</td></tr>
<tr class="memdesc:a5ece54228622ed7124bd002e203f3652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and scatters the result in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#a5ece54228622ed7124bd002e203f3652">More...</a><br /></td></tr>
<tr class="separator:a5ece54228622ed7124bd002e203f3652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9d1f2b9b2156b9624cdabda0d59216"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a5c9d1f2b9b2156b9624cdabda0d59216"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a5c9d1f2b9b2156b9624cdabda0d59216">reduce_scatter</a> (F f, const T *senddata, T *recvdata, const <a class="el" href="classmpl_1_1contiguous__layouts.html">contiguous_layouts</a>&lt; T &gt; &amp;recvcounts) const</td></tr>
<tr class="memdesc:a5c9d1f2b9b2156b9624cdabda0d59216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and scatters the result.  <a href="classmpl_1_1impl_1_1base__communicator.html#a5c9d1f2b9b2156b9624cdabda0d59216">More...</a><br /></td></tr>
<tr class="separator:a5c9d1f2b9b2156b9624cdabda0d59216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5130b267d8d97c911027324fae7b755"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ac5130b267d8d97c911027324fae7b755"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmpl_1_1irequest.html">irequest</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#ac5130b267d8d97c911027324fae7b755">ireduce_scatter</a> (F f, const T *senddata, T *recvdata, <a class="el" href="classmpl_1_1contiguous__layouts.html">contiguous_layouts</a>&lt; T &gt; &amp;recvcounts) const</td></tr>
<tr class="memdesc:ac5130b267d8d97c911027324fae7b755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a reduction operation over all processes and scatters the result in a non-blocking manner.  <a href="classmpl_1_1impl_1_1base__communicator.html#ac5130b267d8d97c911027324fae7b755">More...</a><br /></td></tr>
<tr class="separator:ac5130b267d8d97c911027324fae7b755"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac66083dad051e6b7042d47962d1e2c60"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#ac66083dad051e6b7042d47962d1e2c60">identical</a> = equality_type::identical</td></tr>
<tr class="separator:ac66083dad051e6b7042d47962d1e2c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5ab4324f1a084a93edbbab08bc3d91"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#aec5ab4324f1a084a93edbbab08bc3d91">congruent</a> = equality_type::congruent</td></tr>
<tr class="separator:aec5ab4324f1a084a93edbbab08bc3d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7076a9aaa13cb078e700c0cb616f3f"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#abe7076a9aaa13cb078e700c0cb616f3f">similar</a> = equality_type::similar</td></tr>
<tr class="separator:abe7076a9aaa13cb078e700c0cb616f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10097f544da37d6c9c73606409ed151a"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1communicator.html#a10097f544da37d6c9c73606409ed151a">unequal</a> = equality_type::unequal</td></tr>
<tr class="separator:a10097f544da37d6c9c73606409ed151a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc25b99129227cb025c31e1d12f97cde"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1comm__collective__tag.html">comm_collective_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#acc25b99129227cb025c31e1d12f97cde">comm_collective</a> {}</td></tr>
<tr class="memdesc:acc25b99129227cb025c31e1d12f97cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the creation of a new communicator by an operation that is collective for all processes in the given communicator.  <a href="classmpl_1_1impl_1_1base__communicator.html#acc25b99129227cb025c31e1d12f97cde">More...</a><br /></td></tr>
<tr class="separator:acc25b99129227cb025c31e1d12f97cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be74464ba28c4bb3022029fa7f13f40"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1group__collective__tag.html">group_collective_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a3be74464ba28c4bb3022029fa7f13f40">group_collective</a> {}</td></tr>
<tr class="memdesc:a3be74464ba28c4bb3022029fa7f13f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the creation of a new communicator by an operation that is collective for all processes in the given group.  <a href="classmpl_1_1impl_1_1base__communicator.html#a3be74464ba28c4bb3022029fa7f13f40">More...</a><br /></td></tr>
<tr class="separator:a3be74464ba28c4bb3022029fa7f13f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32074b289551af82033ef77c90b47431"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1split__tag.html">split_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#a32074b289551af82033ef77c90b47431">split</a> {}</td></tr>
<tr class="memdesc:a32074b289551af82033ef77c90b47431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the creation of a new communicator by spitting an existing communicator into disjoint subgroups.  <a href="classmpl_1_1impl_1_1base__communicator.html#a32074b289551af82033ef77c90b47431">More...</a><br /></td></tr>
<tr class="separator:a32074b289551af82033ef77c90b47431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9392fc67c9b2d22a9e429e834937fc"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1split__shared__memory__tag.html">split_shared_memory_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmpl_1_1impl_1_1base__communicator.html#abb9392fc67c9b2d22a9e429e834937fc">split_shared_memory</a> {}</td></tr>
<tr class="memdesc:abb9392fc67c9b2d22a9e429e834937fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the creation of a new communicator by spitting an existing communicator into disjoint subgroups each of which can create a shared memory region.  <a href="classmpl_1_1impl_1_1base__communicator.html#abb9392fc67c9b2d22a9e429e834937fc">More...</a><br /></td></tr>
<tr class="separator:abb9392fc67c9b2d22a9e429e834937fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Communicator with general graph topology. </p>

<p class="definition">Definition at line <a class="el" href="graph__communicator_8hpp_source.html#l00015">15</a> of file <a class="el" href="graph__communicator_8hpp_source.html">graph_communicator.hpp</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="af66054a704ac25557aa25b356e8abd63" name="af66054a704ac25557aa25b356e8abd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66054a704ac25557aa25b356e8abd63">&#9670;&nbsp;</a></span>equality_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">mpl::communicator::equality_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality types for communicator comparison. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af66054a704ac25557aa25b356e8abd63aee0cbdbacdada19376449799774976e8" name="af66054a704ac25557aa25b356e8abd63aee0cbdbacdada19376449799774976e8"></a>identical&#160;</td><td class="fielddoc"><p >communicators are identical, i.e., communicators represent the same communication context </p>
</td></tr>
<tr><td class="fieldname"><a id="af66054a704ac25557aa25b356e8abd63aecf9c13ef0ea0b37562355d0c5f982ac" name="af66054a704ac25557aa25b356e8abd63aecf9c13ef0ea0b37562355d0c5f982ac"></a>congruent&#160;</td><td class="fielddoc"><p >communicators are identical, i.e., communicators have the same members in same rank order but a different context </p>
</td></tr>
<tr><td class="fieldname"><a id="af66054a704ac25557aa25b356e8abd63a10faae554c642e7607b1dd0cc8607703" name="af66054a704ac25557aa25b356e8abd63a10faae554c642e7607b1dd0cc8607703"></a>similar&#160;</td><td class="fielddoc"><p >communicators are similar, i.e., communicators have same the members in different rank order </p>
</td></tr>
<tr><td class="fieldname"><a id="af66054a704ac25557aa25b356e8abd63ab4f45c85d7e3269abe7f894d94bf0f29" name="af66054a704ac25557aa25b356e8abd63ab4f45c85d7e3269abe7f894d94bf0f29"></a>unequal&#160;</td><td class="fielddoc"><p >communicators are unequal, i.e., communicators have different sets of members </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04015">4015</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af81016b2d1c45d91880894f13ba74182" name="af81016b2d1c45d91880894f13ba74182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81016b2d1c45d91880894f13ba74182">&#9670;&nbsp;</a></span>graph_communicator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpl::graph_communicator::graph_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty communicator with no associated process. </p>

</div>
</div>
<a id="ab4242c2300ed9c2d844001847027b148" name="ab4242c2300ed9c2d844001847027b148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4242c2300ed9c2d844001847027b148">&#9670;&nbsp;</a></span>graph_communicator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpl::graph_communicator::graph_communicator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1graph__communicator.html">graph_communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new communicator which is equivalent to an existing one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other communicator to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation that needs to be carried out by all processes of the communicator other. Communicators should not be copied unless a new independent communicator is wanted. Communicators should be passed via references to functions to avoid unnecessary copying. </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph__communicator_8hpp_source.html#l00110">110</a> of file <a class="el" href="graph__communicator_8hpp_source.html">graph_communicator.hpp</a>.</p>

</div>
</div>
<a id="a0053567d5a44c1783b35050f25f99ff0" name="a0053567d5a44c1783b35050f25f99ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0053567d5a44c1783b35050f25f99ff0">&#9670;&nbsp;</a></span>graph_communicator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpl::graph_communicator::graph_communicator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpl_1_1graph__communicator.html">graph_communicator</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs a communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other communicator to move from </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="graph__communicator_8hpp_source.html#l00116">116</a> of file <a class="el" href="graph__communicator_8hpp_source.html">graph_communicator.hpp</a>.</p>

</div>
</div>
<a id="a9b838df23d3b54ac7ff8f249e2a59e64" name="a9b838df23d3b54ac7ff8f249e2a59e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b838df23d3b54ac7ff8f249e2a59e64">&#9670;&nbsp;</a></span>graph_communicator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpl::graph_communicator::graph_communicator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1communicator.html">communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1graph__communicator_1_1edge__set.html">edge_set</a> &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reorder</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new communicator with graph process topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>communicator containing the processes to use in the creation of the new communicator </td></tr>
    <tr><td class="paramname">edges</td><td>represents graph edges of the new communicator </td></tr>
    <tr><td class="paramname">reorder</td><td>indicates if reordering is permitted, if false each process will have the same rank in the new communicator as in the old one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation that needs to be carried out by all processes of the communicator other with the same arguments. </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph__communicator_8hpp_source.html#l00129">129</a> of file <a class="el" href="graph__communicator_8hpp_source.html">graph_communicator.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a396840f91fb5d7b62c0f5128eb93d6ca" name="a396840f91fb5d7b62c0f5128eb93d6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396840f91fb5d7b62c0f5128eb93d6ca">&#9670;&nbsp;</a></span>abort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::abort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aborts all processes associated to the communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>error code, becomes the return code of the main program </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Method provides just a "best attempt" to abort processes. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="arrays_8cc-example.html#a3">arrays.cc</a>, <a class="el" href="iterators_8cc-example.html#a3">iterators.cc</a>, <a class="el" href="standard_types_8cc-example.html#a5">standard_types.cc</a>, <a class="el" href="stl_container_8cc-example.html#a10">stl_container.cc</a>, and <a class="el" href="struct_8cc-example.html#a3">struct.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00487">487</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="abcd0c45df8daca2f36291951effb8153" name="abcd0c45df8daca2f36291951effb8153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd0c45df8daca2f36291951effb8153">&#9670;&nbsp;</a></span>allgather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::allgather </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes and distribute result to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="parallel_sort_mpl_8cc-example.html#a3">parallel_sort_mpl.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02673">2673</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac77e03595a19600fcc37cc46056bcf3d" name="ac77e03595a19600fcc37cc46056bcf3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77e03595a19600fcc37cc46056bcf3d">&#9670;&nbsp;</a></span>allgather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::allgather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes and distribute result to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02688">2688</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a29e32e8519c9195e37e9aefb3370075c" name="a29e32e8519c9195e37e9aefb3370075c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e32e8519c9195e37e9aefb3370075c">&#9670;&nbsp;</a></span>allgatherv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::allgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes and distribute result to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02769">2769</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="abe706e36c83be1873aa6ee150b945e5a" name="abe706e36c83be1873aa6ee150b945e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe706e36c83be1873aa6ee150b945e5a">&#9670;&nbsp;</a></span>allgatherv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::allgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes and distribute result to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02748">2748</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ad5ac09052c33e0c84be8ae3ee6d5a334" name="ad5ac09052c33e0c84be8ae3ee6d5a334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ac09052c33e0c84be8ae3ee6d5a334">&#9670;&nbsp;</a></span>allreduce() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::allreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03521">3521</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a0c10d9332032baaf40a9e920f86cb28f" name="a0c10d9332032baaf40a9e920f86cb28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c10d9332032baaf40a9e920f86cb28f">&#9670;&nbsp;</a></span>allreduce() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::allreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03538">3538</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a0a2866d44cee859fc064e2e32a6710d7" name="a0a2866d44cee859fc064e2e32a6710d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2866d44cee859fc064e2e32a6710d7">&#9670;&nbsp;</a></span>allreduce() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::allreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="collective_8cc-example.html#a11">collective.cc</a>, and <a class="el" href="communicator_8cc-example.html#a7">communicator.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04466">4466</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a55feab940e9c72241215918199931936" name="a55feab940e9c72241215918199931936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55feab940e9c72241215918199931936">&#9670;&nbsp;</a></span>allreduce() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::allreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04483">4483</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2f751fb0c400872c55249220e2d8eb99" name="a2f751fb0c400872c55249220e2d8eb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f751fb0c400872c55249220e2d8eb99">&#9670;&nbsp;</a></span>alltoall() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::alltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layouts of the data to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. The memory layouts of the incoming and the outgoing messages are described by sendl and recvl. Both layouts might differ but must be compatible, i.e., must hold the same number of elements of type T. The i-th memory block with the layout sendl in the array senddata is sent to the i-th process. When the function has finished, the i-th memory block with the layout recvl in the array recvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03148">3148</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a3f5ca17cb762ed1e57d213a5a07f3752" name="a3f5ca17cb762ed1e57d213a5a07f3752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5ca17cb762ed1e57d213a5a07f3752">&#9670;&nbsp;</a></span>alltoall() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::alltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends one element of type T to each process (including itself) and receives one element of type T from each process. The i-th element in the array senddata is sent to the i-th process. When the function has finished, the i-th element in the array recvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03126">3126</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ad709e10e351d9ffd4dd9917a9b697c19" name="ad709e10e351d9ffd4dd9917a9b697c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad709e10e351d9ffd4dd9917a9b697c19">&#9670;&nbsp;</a></span>alltoall() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::alltoall </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes, in-place version. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecvdata</td><td>pointer to continuous storage for outgoing messages and for incoming messages</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends one element of type T to each process (including itself) and receives one element of type T from each process. The i-th element in the array sendrecvdata is sent to the i-th process. When the function has finished, the i-th element in the array sendrecvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04070">4070</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a88368d3f4d7b375825ba839746aea7dd" name="a88368d3f4d7b375825ba839746aea7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88368d3f4d7b375825ba839746aea7dd">&#9670;&nbsp;</a></span>alltoall() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::alltoall </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendrecvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes, in-place version. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecvdata</td><td>pointer to continuous storage for outgoing messages and for incoming messages </td></tr>
    <tr><td class="paramname">sendrecvl</td><td>memory layouts of the data to send and to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. The memory layouts of the incoming and the outgoing messages are described by sendrecvl. The i-th memory block with the layout sendrecvl in the array sendrecvdata is sent to the i-th process. When the function has finished, the i-th memory block with the layout sendrecvl in the array sendrecvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04091">4091</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ade9edec8368db00f56b7fe7c648b60eb" name="ade9edec8368db00f56b7fe7c648b60eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9edec8368db00f56b7fe7c648b60eb">&#9670;&nbsp;</a></span>alltoallv() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::alltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>senddispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">senddispls</td><td>displacements of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffers senddata and recvdata, respectively. The i-th memory block with the layout sendls[i] in the array senddata starts senddispls[i] bytes after the address given in senddata. The i-th memory block is sent to the i-th process. The i-th memory block with the layout recvls[i] in the array recvdata starts recvdispls[i] bytes after the address given in recvdata. When the function has finished, the i-th memory block in the array recvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03230">3230</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a38f25701315e92089bf34cf63aba4b56" name="a38f25701315e92089bf34cf63aba4b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f25701315e92089bf34cf63aba4b56">&#9670;&nbsp;</a></span>alltoallv() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::alltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffers senddata and recvdata, respectively. The i-th memory block with the layout sendls[i] in the array senddata starts at the address given in senddata. The i-th memory block is sent to the i-th process. The i-th memory block with the layout recvls[i] in the array recvdata starts at the address given in recvdata. Note that the memory layouts need to include appropriate holes at the beginning in order to avoid overlapping send- or receive blocks. When the function has finished, the i-th memory block in the array recvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03270">3270</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="afcb7048f892b4c371bba2e261e565656" name="afcb7048f892b4c371bba2e261e565656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb7048f892b4c371bba2e261e565656">&#9670;&nbsp;</a></span>alltoallv() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::alltoallv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendrecvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecvdata</td><td>pointer to continuous storage for incoming and outgoing messages </td></tr>
    <tr><td class="paramname">sendrecvls</td><td>memory layouts of the data to send and to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffer sendrecvdata. The i-th memory block with the layout sendrecvls[i] in the array sendrecvdata starts at the address given in sendrecvdata. The i-th memory block is sent to the i-th process. Note that the memory layouts need to include appropriate holes at the beginning in order to avoid overlapping send-receive blocks. When the function has finished, the i-th memory block in the array sendrecvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04196">4196</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a4db43a46f468c60e84b35f95577ff0f4" name="a4db43a46f468c60e84b35f95577ff0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db43a46f468c60e84b35f95577ff0f4">&#9670;&nbsp;</a></span>alltoallv() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::alltoallv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendrecvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>sendrecvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecvdata</td><td>pointer to continuous storage for outgoing and incoming messages </td></tr>
    <tr><td class="paramname">sendrecvls</td><td>memory layouts of the data to send and to receive </td></tr>
    <tr><td class="paramname">sendrecvdispls</td><td>displacements of the data to send and to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffer sendecvdata. The i-th memory block with the layout sendlrecvs[i] in the array sendrecvdata starts sendrecvdispls[i] bytes after the address given in sendrecvdata. The i-th memory block is sent to the i-th process. When the function has finished, the i-th memory block in the array sendrecvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="matrix_gather_8cc-example.html#a12">matrix_gather.cc</a>, and <a class="el" href="parallel_sort_mpl_8cc-example.html#a7">parallel_sort_mpl.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04167">4167</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a4ea2476951464fc6f12c3059d13b5bb9" name="a4ea2476951464fc6f12c3059d13b5bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea2476951464fc6f12c3059d13b5bb9">&#9670;&nbsp;</a></span>barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks until all processes in the communicator have reached this method. </p>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="collective_8cc-example.html#a2">collective.cc</a>, and <a class="el" href="communicator_8cc-example.html#a4">communicator.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02289">2289</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8c7f1e51ab84e36fe669f630478a43be" name="a8c7f1e51ab84e36fe669f630478a43be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7f1e51ab84e36fe669f630478a43be">&#9670;&nbsp;</a></span>bcast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::bcast </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts a message from a process to all other processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">data</td><td>buffer for sending/receiving data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="collective_8cc-example.html#a5">collective.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02312">2312</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aec2f6c2599fd0e04890eddfe02d9ae82" name="aec2f6c2599fd0e04890eddfe02d9ae82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2f6c2599fd0e04890eddfe02d9ae82">&#9670;&nbsp;</a></span>bcast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::bcast </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts a message from a process to all other processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">data</td><td>buffer for sending/receiving data </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send/receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02326">2326</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="af2de6caeb0acc8f8398892f4b4b1a2cd" name="af2de6caeb0acc8f8398892f4b4b1a2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2de6caeb0acc8f8398892f4b4b1a2cd">&#9670;&nbsp;</a></span>bsend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::bsend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a single value via a buffered send operation. </p>
<p ><a class="anchor" id="communicator_bsend"></a></p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="blocking_8cc-example.html#a7">blocking.cc</a>, and <a class="el" href="blocking_vector_8cc-example.html#a8">blocking_vector.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00834">834</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a9ff7f9049631874e960562ac474abdc0" name="a9ff7f9049631874e960562ac474abdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff7f9049631874e960562ac474abdc0">&#9670;&nbsp;</a></span>bsend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::bsend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values having a specific memory layout via a buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00850">850</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aab5d81a319710f9a0ce253dd7bee06f9" name="aab5d81a319710f9a0ce253dd7bee06f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5d81a319710f9a0ce253dd7bee06f9">&#9670;&nbsp;</a></span>bsend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::bsend </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00871">871</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a45183e7f974388046dbe61f6dbc05e61" name="a45183e7f974388046dbe61f6dbc05e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45183e7f974388046dbe61f6dbc05e61">&#9670;&nbsp;</a></span>bsend_init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::bsend_init </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a single value via a buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01017">1017</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="acdc74ae1c4006da62a17197e5854eb6f" name="acdc74ae1c4006da62a17197e5854eb6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc74ae1c4006da62a17197e5854eb6f">&#9670;&nbsp;</a></span>bsend_init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::bsend_init </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values having a specific memory layout via a buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01036">1036</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a923344b718948986f2fca9b8efbcf012" name="a923344b718948986f2fca9b8efbcf012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923344b718948986f2fca9b8efbcf012">&#9670;&nbsp;</a></span>bsend_init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::bsend_init </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values given by a pair of iterators via a buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01061">1061</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a44cf69c80f9698d438dd6623f0b3bbb0" name="a44cf69c80f9698d438dd6623f0b3bbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cf69c80f9698d438dd6623f0b3bbb0">&#9670;&nbsp;</a></span>bsend_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mpl::impl::base_communicator::bsend_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the message buffer size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send in a later buffered send operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>layout of the data </td></tr>
    <tr><td class="paramname">number</td><td>quantity of buffered send operations with the given data type and layout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>message buffer size </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00789">789</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2cbb41cb9c5945966bda543ef82a16a5" name="a2cbb41cb9c5945966bda543ef82a16a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbb41cb9c5945966bda543ef82a16a5">&#9670;&nbsp;</a></span>bsend_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mpl::impl::base_communicator::bsend_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the message buffer size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send in a later buffered send operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>quantity of elements of type T to send in a single buffered message or in a series of buffered send operations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>message buffer size <a class="anchor" id="communicator_bsend_size"></a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="blocking_8cc-example.html#a5">blocking.cc</a>, <a class="el" href="blocking_vector_8cc-example.html#a6">blocking_vector.cc</a>, and <a class="el" href="nonblocking_8cc-example.html#a7">nonblocking.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00776">776</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a7b672d71b83fafca8f6bf4d435331180" name="a7b672d71b83fafca8f6bf4d435331180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b672d71b83fafca8f6bf4d435331180">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a> mpl::communicator::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1communicator.html">communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares to another communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>communicator to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>equality type </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04045">4045</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a17dd29d46d12c1cafd0d4b9f7aa4f8e7" name="a17dd29d46d12c1cafd0d4b9f7aa4f8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17dd29d46d12c1cafd0d4b9f7aa4f8e7">&#9670;&nbsp;</a></span>degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mpl::graph_communicator::degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of neighbours of the calling process. </p>
<dl class="section return"><dt>Returns</dt><dd>number of direct neighbours of the calling process </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph__communicator_8hpp_source.html#l00202">202</a> of file <a class="el" href="graph__communicator_8hpp_source.html">graph_communicator.hpp</a>.</p>

</div>
</div>
<a id="a545def7768f6786e06c36277c1d21cde" name="a545def7768f6786e06c36277c1d21cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545def7768f6786e06c36277c1d21cde">&#9670;&nbsp;</a></span>degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mpl::graph_communicator::degree </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of neighbours of some process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>process rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of direct neighbours of the process with the given rank </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph__communicator_8hpp_source.html#l00194">194</a> of file <a class="el" href="graph__communicator_8hpp_source.html">graph_communicator.hpp</a>.</p>

</div>
</div>
<a id="a20b0a5d186d8bac256432060db9e0303" name="a20b0a5d186d8bac256432060db9e0303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b0a5d186d8bac256432060db9e0303">&#9670;&nbsp;</a></span>exscan() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::exscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs partial reduction operation (exclusive scan) over all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03814">3814</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a9d2b304977b516e327e5003282ff3fb1" name="a9d2b304977b516e327e5003282ff3fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2b304977b516e327e5003282ff3fb1">&#9670;&nbsp;</a></span>exscan() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::exscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (exclusive scan) over all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03831">3831</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ad67313aace6a05f58081939eb1d2a4b8" name="ad67313aace6a05f58081939eb1d2a4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67313aace6a05f58081939eb1d2a4b8">&#9670;&nbsp;</a></span>exscan() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::exscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (exclusive scan) over all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04625">4625</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a45585975b4b7cc0795a02abf6494963b" name="a45585975b4b7cc0795a02abf6494963b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45585975b4b7cc0795a02abf6494963b">&#9670;&nbsp;</a></span>exscan() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::exscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (exclusive scan) over all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04642">4642</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a39eb16ddb0c7a7a6c942fa97eef2dc24" name="a39eb16ddb0c7a7a6c942fa97eef2dc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39eb16ddb0c7a7a6c942fa97eef2dc24">&#9670;&nbsp;</a></span>gather() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::gather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02462">2462</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="acb69ffd367e57984c967122b4a2f97fe" name="acb69ffd367e57984c967122b4a2f97fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb69ffd367e57984c967122b4a2f97fe">&#9670;&nbsp;</a></span>gather() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::gather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="collective_8cc-example.html#a7">collective.cc</a>, and <a class="el" href="gather_8cc-example.html#a4">gather.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02383">2383</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="afa6b9dc95c95ef4bcb939f4b9d5b9f18" name="afa6b9dc95c95ef4bcb939f4b9d5b9f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6b9dc95c95ef4bcb939f4b9d5b9f18">&#9670;&nbsp;</a></span>gather() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::gather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">senddata</td><td>data buffer for sending data </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02478">2478</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a97b4d15457ea636b95e549fbb5aec6e7" name="a97b4d15457ea636b95e549fbb5aec6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b4d15457ea636b95e549fbb5aec6e7">&#9670;&nbsp;</a></span>gather() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::gather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">senddata</td><td>data buffer for sending data </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02400">2400</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8ff55b7fd641226e881ed6c8e4fd69b3" name="a8ff55b7fd641226e881ed6c8e4fd69b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff55b7fd641226e881ed6c8e4fd69b3">&#9670;&nbsp;</a></span>gatherv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::gatherv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes at a single root process. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02630">2630</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ad29e5b6744d628dea82c7dba0079ddc4" name="ad29e5b6744d628dea82c7dba0079ddc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29e5b6744d628dea82c7dba0079ddc4">&#9670;&nbsp;</a></span>gatherv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::gatherv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes at a single root process. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02565">2565</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a991f687ee554c4a76ff920b6935ef407" name="a991f687ee554c4a76ff920b6935ef407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991f687ee554c4a76ff920b6935ef407">&#9670;&nbsp;</a></span>gatherv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::gatherv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes at a single root process. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive by the root rank </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="distributed_grid_scatter_gather_8cc-example.html#a8">distributed_grid_scatter_gather.cc</a>, <a class="el" href="gatherv_8cc-example.html#a7">gatherv.cc</a>, <a class="el" href="heat_equation__jacobi_method_8cc-example.html#a21">heat_equation_Jacobi_method.cc</a>, <a class="el" href="heat_equation_successive_over-relaxation_8cc-example.html#a22">heat_equation_successive_over-relaxation.cc</a>, <a class="el" href="matrix_gather_8cc-example.html#a10">matrix_gather.cc</a>, and <a class="el" href="vibrating_string_mpl_8cc-example.html#a13">vibrating_string_mpl.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02538">2538</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a5d4576dc948f8caf806b18dab1741150" name="a5d4576dc948f8caf806b18dab1741150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4576dc948f8caf806b18dab1741150">&#9670;&nbsp;</a></span>iallgather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iallgather </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes and distribute result to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02706">2706</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a663729ac6fc2228d97cd6a731d7393ac" name="a663729ac6fc2228d97cd6a731d7393ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663729ac6fc2228d97cd6a731d7393ac">&#9670;&nbsp;</a></span>iallgather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iallgather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes and distribute result to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02725">2725</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a807a21d0db687f61528cd8dc0816e6c1" name="a807a21d0db687f61528cd8dc0816e6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807a21d0db687f61528cd8dc0816e6c1">&#9670;&nbsp;</a></span>iallgatherv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iallgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes and distribute result to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02810">2810</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aa313a0f605d5da994a8a712ddcf791ec" name="aa313a0f605d5da994a8a712ddcf791ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa313a0f605d5da994a8a712ddcf791ec">&#9670;&nbsp;</a></span>iallgatherv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iallgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes and distribute result to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02788">2788</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a4f7300592e555f22a9729addc081136e" name="a4f7300592e555f22a9729addc081136e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7300592e555f22a9729addc081136e">&#9670;&nbsp;</a></span>iallreduce() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iallreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03557">3557</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ab68d3aa79481f7c1828fc9938e0bd960" name="ab68d3aa79481f7c1828fc9938e0bd960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68d3aa79481f7c1828fc9938e0bd960">&#9670;&nbsp;</a></span>iallreduce() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iallreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03578">3578</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a5ce91750a7c77edf43e53ac88e4e8524" name="a5ce91750a7c77edf43e53ac88e4e8524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce91750a7c77edf43e53ac88e4e8524">&#9670;&nbsp;</a></span>iallreduce() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::iallreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04502">4502</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aa50f2d3ad4ca9b8e917997c0aa211edf" name="aa50f2d3ad4ca9b8e917997c0aa211edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50f2d3ad4ca9b8e917997c0aa211edf">&#9670;&nbsp;</a></span>iallreduce() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::iallreduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and broadcasts the result in non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04522">4522</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ab78219b6f443eb6ab610691db2c63b1f" name="ab78219b6f443eb6ab610691db2c63b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78219b6f443eb6ab610691db2c63b1f">&#9670;&nbsp;</a></span>ialltoall() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ialltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. The memory layouts of the incoming and the outgoing messages are described by sendl and recvl. Both layouts might differ but must be compatible, i.e., must hold the same number of elements of type T. The i-th memory block with the layout sendl in the array senddata is sent to the i-th process. When the message transfer has finished, the i-th memory block with the layout recvl in the array recvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03196">3196</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a6340db4f70de6bd6877daa489e5a9cee" name="a6340db4f70de6bd6877daa489e5a9cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6340db4f70de6bd6877daa489e5a9cee">&#9670;&nbsp;</a></span>ialltoall() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ialltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends one element of type T to each process (including itself) and receives one element of type T from each process. The i-th element in the array senddata is sent to the i-th process. When the message transfer has finished, the i-th element in the array recvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03170">3170</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aadb9f14a7a9f9bd44eae7832daed895d" name="aadb9f14a7a9f9bd44eae7832daed895d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb9f14a7a9f9bd44eae7832daed895d">&#9670;&nbsp;</a></span>ialltoall() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ialltoall </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes in a non-blocking manner, in-place version. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecvdata</td><td>pointer to continuous storage for outgoing messages and for incoming messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends one element of type T to each process (including itself) and receives one element of type T from each process. The i-th element in the array sendrecvdata is sent to the i-th process. When the message transfer has finished, the i-th element in the array sendrecvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04112">4112</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="abe91007be7acef7641d6cbb08526d53b" name="abe91007be7acef7641d6cbb08526d53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe91007be7acef7641d6cbb08526d53b">&#9670;&nbsp;</a></span>ialltoall() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ialltoall </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendrecvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all processes and receives messages from all processes in a non-blocking manner, in-place version. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecvdata</td><td>pointer to continuous storage for outgoing messages and for incoming messages </td></tr>
    <tr><td class="paramname">sendrecvl</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. The memory layouts of the incoming and the outgoing messages are described by sendrecvl. The i-th memory block with the layout sendrecvl in the array sendrecvdata is sent to the i-th process. When the message transfer has finished, the i-th memory block with the layout sendrecvl in the array sendrecvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04137">4137</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ad4e1317ecddf63366a5398f1d83dfb33" name="ad4e1317ecddf63366a5398f1d83dfb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e1317ecddf63366a5398f1d83dfb33">&#9670;&nbsp;</a></span>ialltoallv() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ialltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>senddispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">senddispls</td><td>displacements of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffers senddata and recvdata, respectively. The i-th memory block with the layout sendls[i] in the array senddata starts senddispls[i] bytes after the address given in senddata. The i-th memory block is sent to the i-th process. The i-th memory block with the layout recvls[i] in the array recvdata starts recvdispls[i] bytes after the address given in recvdata. When the function has finished, the i-th memory block in the array recvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03370">3370</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a0b622fafeeb9d6a637e17d244c24deac" name="a0b622fafeeb9d6a637e17d244c24deac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b622fafeeb9d6a637e17d244c24deac">&#9670;&nbsp;</a></span>ialltoallv() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ialltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffers senddata and recvdata, respectively. The i-th memory block with the layout sendls[i] in the array senddata starts at the address given in senddata. The i-th memory block is sent to the i-th process. The i-th memory block with the layout recvls[i] in the array recvdata starts at the address given in recvdata. Note that the memory layouts need to include appropriate holes at the beginning in order to avoid overlapping send- or receive blocks. When the function has finished, the i-th memory block in the array recvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03414">3414</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a7abdf44a7c377ba7191cb4abc6648afe" name="a7abdf44a7c377ba7191cb4abc6648afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abdf44a7c377ba7191cb4abc6648afe">&#9670;&nbsp;</a></span>ialltoallv() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ialltoallv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendrecvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecvdata</td><td>pointer to continuous storage for incoming and outgoing messages </td></tr>
    <tr><td class="paramname">sendrecvls</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffer sendrecvdata. The i-th memory block with the layout sendrecvls[i] in the array sendrecvdata starts at the address given in sendrecvdata. The i-th memory block is sent to the i-th process. Note that the memory layouts need to include appropriate holes at the beginning in order to avoid overlapping send-receive blocks. When the function has finished, the i-th memory block in the array sendrecvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04258">4258</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a5664d9591456924a7343082445bc8452" name="a5664d9591456924a7343082445bc8452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5664d9591456924a7343082445bc8452">&#9670;&nbsp;</a></span>ialltoallv() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ialltoallv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendrecvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>sendrecvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all processes and receives messages with a variable amount of data from all processes in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sendrecvdata</td><td>pointer to continuous storage for outgoing and incoming messages </td></tr>
    <tr><td class="paramname">sendrecvls</td><td>memory layouts of the data to send and to receive </td></tr>
    <tr><td class="paramname">sendrecvdispls</td><td>displacements of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each process (including itself) and receives elements of type T from each process. Send- and receive-data are stored in consecutive blocks of variable size in the buffer sendecvdata. The i-th memory block with the layout sendlrecvs[i] in the array sendrecvdata starts sendrecvdispls[i] bytes after the address given in sendrecvdata. The i-th memory block is sent to the i-th process. When the function has finished, the i-th memory block in the array sendrecvdata was received from the i-th process. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04220">4220</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aaa87e0859e0936b4c436757025e14cdd" name="aaa87e0859e0936b4c436757025e14cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa87e0859e0936b4c436757025e14cdd">&#9670;&nbsp;</a></span>ibarrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ibarrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies the process that it has reached the barrier and returns immediately. </p>
<dl class="section return"><dt>Returns</dt><dd>communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02296">2296</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a0f91ffcfc0640d8e493e60fd1ce4ce49" name="a0f91ffcfc0640d8e493e60fd1ce4ce49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f91ffcfc0640d8e493e60fd1ce4ce49">&#9670;&nbsp;</a></span>ibcast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ibcast </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts a message from a process to all other processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">data</td><td>buffer for sending/receiving data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02343">2343</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aaa47dbaa764103a4992654373dc083c9" name="aaa47dbaa764103a4992654373dc083c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa47dbaa764103a4992654373dc083c9">&#9670;&nbsp;</a></span>ibcast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ibcast </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts a message from a process to all other processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">data</td><td>buffer for sending/receiving data </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send/receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02362">2362</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8b89a2050b73fce16138c4fda3f7872d" name="a8b89a2050b73fce16138c4fda3f7872d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b89a2050b73fce16138c4fda3f7872d">&#9670;&nbsp;</a></span>ibsend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ibsend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a single value via a non-blocking buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. <a class="anchor" id="communicator_ibsend"></a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="nonblocking_8cc-example.html#a9">nonblocking.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00950">950</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aedf3f4909faf1036124b1247079b6af6" name="aedf3f4909faf1036124b1247079b6af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf3f4909faf1036124b1247079b6af6">&#9670;&nbsp;</a></span>ibsend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ibsend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with several values having a specific memory layout via a non-blocking buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00968">968</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ad915ee85eb905b4edaa2ade85ec4cc58" name="ad915ee85eb905b4edaa2ade85ec4cc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad915ee85eb905b4edaa2ade85ec4cc58">&#9670;&nbsp;</a></span>ibsend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ibsend </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a non-blocking buffered send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00993">993</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2ebd5cd79b037726a7570177f63891dc" name="a2ebd5cd79b037726a7570177f63891dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebd5cd79b037726a7570177f63891dc">&#9670;&nbsp;</a></span>iexscan() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iexscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03850">3850</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aba116e6d2045fde1f15fe6dc14bd0c75" name="aba116e6d2045fde1f15fe6dc14bd0c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba116e6d2045fde1f15fe6dc14bd0c75">&#9670;&nbsp;</a></span>iexscan() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iexscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03871">3871</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a20766ee389c97340241ff730eae49475" name="a20766ee389c97340241ff730eae49475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20766ee389c97340241ff730eae49475">&#9670;&nbsp;</a></span>iexscan() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::iexscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04661">4661</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8e43e08af5e8481049731092274aca76" name="a8e43e08af5e8481049731092274aca76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e43e08af5e8481049731092274aca76">&#9670;&nbsp;</a></span>iexscan() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::iexscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (exclusive scan) over all processes in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04681">4681</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac7f523b45eac440adecaab3f7a07cd43" name="ac7f523b45eac440adecaab3f7a07cd43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f523b45eac440adecaab3f7a07cd43">&#9670;&nbsp;</a></span>igather() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::igather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02496">2496</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ae52b0fb0f22cdb5fbcd6947c14841baa" name="ae52b0fb0f22cdb5fbcd6947c14841baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52b0fb0f22cdb5fbcd6947c14841baa">&#9670;&nbsp;</a></span>igather() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::igather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02421">2421</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aa84772592ff24d7a2d0086ad0e3fe9fb" name="aa84772592ff24d7a2d0086ad0e3fe9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84772592ff24d7a2d0086ad0e3fe9fb">&#9670;&nbsp;</a></span>igather() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::igather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">senddata</td><td>data buffer for sending data </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02516">2516</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a3ceeaff35297ef5c90df1a24ae28ed9d" name="a3ceeaff35297ef5c90df1a24ae28ed9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ceeaff35297ef5c90df1a24ae28ed9d">&#9670;&nbsp;</a></span>igather() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::igather </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all processes at a single root process in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">senddata</td><td>data buffer for sending data </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02442">2442</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a1823308d45ebd071938597345ddc6f45" name="a1823308d45ebd071938597345ddc6f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1823308d45ebd071938597345ddc6f45">&#9670;&nbsp;</a></span>igatherv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::igatherv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes at a single root process in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02652">2652</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a82d4e6d9f819b35ab72606728b9f5e99" name="a82d4e6d9f819b35ab72606728b9f5e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d4e6d9f819b35ab72606728b9f5e99">&#9670;&nbsp;</a></span>igatherv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::igatherv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes at a single root process in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02614">2614</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aafcc5b4f2087a49ed620a170165217d9" name="aafcc5b4f2087a49ed620a170165217d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcc5b4f2087a49ed620a170165217d9">&#9670;&nbsp;</a></span>igatherv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::igatherv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all processes at a single root process in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive by the root rank </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02585">2585</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a0ec9bf459e52d421c99686aa1efaea6a" name="a0ec9bf459e52d421c99686aa1efaea6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec9bf459e52d421c99686aa1efaea6a">&#9670;&nbsp;</a></span>improbe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structmpl_1_1mprobe__status.html">mprobe_status</a> &gt; mpl::impl::base_communicator::improbe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking matched test for an incoming message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>message handle and status of the pending message if there is a pending message by the given source and with the given tag </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01957">1957</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a6ad22c8b3483384b4f141cf5721f4b40" name="a6ad22c8b3483384b4f141cf5721f4b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad22c8b3483384b4f141cf5721f4b40">&#9670;&nbsp;</a></span>imrecv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::imrecv </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a several values given by a pair of iterators via a non-blocking receive operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to receive </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to receive </td></tr>
    <tr><td class="paramname">m</td><td>message handle of message to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02091">2091</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a0c42ccf3d4fa5b826970d51c3ceb37ae" name="a0c42ccf3d4fa5b826970d51c3ceb37ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c42ccf3d4fa5b826970d51c3ceb37ae">&#9670;&nbsp;</a></span>imrecv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::imrecv </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a single value via a non-blocking receive operation by a message handle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to receive </td></tr>
    <tr><td class="paramname">m</td><td>message handle of message to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing receive operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Receiving STL containers is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02058">2058</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a55a829a6fb9fb725f35dfa84b4fee55f" name="a55a829a6fb9fb725f35dfa84b4fee55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a829a6fb9fb725f35dfa84b4fee55f">&#9670;&nbsp;</a></span>imrecv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::imrecv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with several values having a specific memory layout via a non-blocking receive operation by a message handle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to receive </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to receive </td></tr>
    <tr><td class="paramname">m</td><td>message handle of message to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02071">2071</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a48dc51499372d1bbef91b06a93f9c275" name="a48dc51499372d1bbef91b06a93f9c275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dc51499372d1bbef91b06a93f9c275">&#9670;&nbsp;</a></span>ineighbor_allgather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_allgather </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all neighboring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send to all neighbours </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00078">78</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a0106f906615b9eed23c4261abba478d7" name="a0106f906615b9eed23c4261abba478d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0106f906615b9eed23c4261abba478d7">&#9670;&nbsp;</a></span>ineighbor_allgather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_allgather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all neighboring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send to all neighbours </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00097">97</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="abd5b018990b3ec2bb3c7daf6f5eae11a" name="abd5b018990b3ec2bb3c7daf6f5eae11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5b018990b3ec2bb3c7daf6f5eae11a">&#9670;&nbsp;</a></span>ineighbor_allgatherv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_allgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all neighbouring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00177">177</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a689162e612c758a55f27811051323739" name="a689162e612c758a55f27811051323739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689162e612c758a55f27811051323739">&#9670;&nbsp;</a></span>ineighbor_allgatherv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_allgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all neighbouring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00156">156</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a6fd0c6abb90218c58a6a02a9b6428231" name="a6fd0c6abb90218c58a6a02a9b6428231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd0c6abb90218c58a6a02a9b6428231">&#9670;&nbsp;</a></span>ineighbor_alltoall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_alltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all neighbouring processes and receives messages from all neighbouring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each neighbouring process and receives elements of type T from each neighbouring process. The memory layouts of the incoming and the outgoing messages are described by sendl and recvl. Both layouts might differ but must be compatible, i.e., must hold the same number of elements of type T. The i-th memory block with the layout sendl in the array senddata is sent to the i-th neighbour. When the function has finished, the i-th memory block with the layout recvl in the array recvdata was received from the i-th neighbour. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00273">273</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a52b9bcc6355597f6294e82b22687c116" name="a52b9bcc6355597f6294e82b22687c116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b9bcc6355597f6294e82b22687c116">&#9670;&nbsp;</a></span>ineighbor_alltoall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_alltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all neighbouring processes and receives messages from all neighbouring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends one element of type T to each neighbouring process and receives one element of type T from each neighbouring process. The i-th element in the array senddata is sent to the i-th neighbour. When the function has finished, the i-th element in the array recvdata was received from the i-th neighbour. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00246">246</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="aaf3b9fce1c6ada4e1110ac9694a19422" name="aaf3b9fce1c6ada4e1110ac9694a19422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3b9fce1c6ada4e1110ac9694a19422">&#9670;&nbsp;</a></span>ineighbor_alltoallv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_alltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>senddispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">senddispls</td><td>displacements of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each neighbor and receives elements of type T from each neighbour. Send- and receive-data are stored in consecutive blocks of variable size in the buffers senddata and recvdata, respectively. The i-th memory block with the layout sendls[i] in the array senddata starts senddispls[i] bytes after the address given in senddata. The i-th memory block is sent to the i-th neighbor. The i-th memory block with the layout recvls[i] in the array recvdata starts recvdispls[i] bytes after the address given in recvdata. When the function has finished, the i-th memory block in the array recvdata was received from the i-th neighbor. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00372">372</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a962c6eec0ae1ff20d3569fd3f10d2471" name="a962c6eec0ae1ff20d3569fd3f10d2471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962c6eec0ae1ff20d3569fd3f10d2471">&#9670;&nbsp;</a></span>ineighbor_alltoallv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">mpl::irequest</a> mpl::impl::topology_communicator::ineighbor_alltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer</dd></dl>
<p>Each process in the communicator sends elements of type T to each neighbour and receives elements of type T from each neighbour. Send- and receive-data are stored in consecutive blocks of variable size in the buffers senddata and recvdata, respectively. The i-th memory block with the layout sendls[i] in the array senddata starts at the address given in senddata. The i-th memory block is sent to the i-th neighbour. The i-th memory block with the layout recvls[i] in the array recvdata starts at the address given in recvdata. Note that the memory layouts need to include appropriate holes at the beginning in order to avoid overlapping send- or receive blocks. When the function has finished, the i-th memory block in the array recvdata was received from the i-th neighbour. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00411">411</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a5e99359be32a4d45501830f900284a06" name="a5e99359be32a4d45501830f900284a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e99359be32a4d45501830f900284a06">&#9670;&nbsp;</a></span>iprobe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmpl_1_1status__t.html">status_t</a> &gt; mpl::impl::base_communicator::iprobe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-blocking test for an incoming message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the pending message if there is any pending message </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01924">1924</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a9a2f8c410dadb02c2247b76c94a38dc4" name="a9a2f8c410dadb02c2247b76c94a38dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2f8c410dadb02c2247b76c94a38dc4">&#9670;&nbsp;</a></span>irecv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::irecv </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a several values given by a pair of iterators via a non-blocking receive operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to receive </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01827">1827</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ab2bca7804e7a466fff401a8aa823f292" name="ab2bca7804e7a466fff401a8aa823f292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bca7804e7a466fff401a8aa823f292">&#9670;&nbsp;</a></span>irecv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::irecv </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a single value via a non-blocking receive operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing receive operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Receiving STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="heat_equation__jacobi_method_8cc-example.html#a11">heat_equation_Jacobi_method.cc</a>, <a class="el" href="heat_equation_successive_over-relaxation_8cc-example.html#a11">heat_equation_successive_over-relaxation.cc</a>, <a class="el" href="nonblocking_8cc-example.html#a17">nonblocking.cc</a>, <a class="el" href="nonblocking_mult_8cc-example.html#a8">nonblocking_mult.cc</a>, <a class="el" href="stl_container_8cc-example.html#a6">stl_container.cc</a>, and <a class="el" href="vibrating_string_mpl_8cc-example.html#a8">vibrating_string_mpl.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01786">1786</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a11f8ca1551c24cce5b98ae1531c63892" name="a11f8ca1551c24cce5b98ae1531c63892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f8ca1551c24cce5b98ae1531c63892">&#9670;&nbsp;</a></span>irecv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::irecv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with several values having a specific memory layout via a non-blocking receive operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to receive </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01803">1803</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a79e5f4cd63cf9354ceedc4da193e2410" name="a79e5f4cd63cf9354ceedc4da193e2410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e5f4cd63cf9354ceedc4da193e2410">&#9670;&nbsp;</a></span>ireduce() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ireduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes in a non-blocking manner, non-root in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result, must be different from the rank of the calling process </td></tr>
    <tr><td class="paramname">senddata</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04390">4390</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aaf4e60d9ca331f32342631fca0c7b74c" name="aaf4e60d9ca331f32342631fca0c7b74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4e60d9ca331f32342631fca0c7b74c">&#9670;&nbsp;</a></span>ireduce() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ireduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">senddata</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the result of the reduction operation if rank equals root_rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03476">3476</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="abdb6d8fc8a9aafabf50b96275f09775d" name="abdb6d8fc8a9aafabf50b96275f09775d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb6d8fc8a9aafabf50b96275f09775d">&#9670;&nbsp;</a></span>ireduce() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ireduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes in a non-blocking manner, non-root in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result, must be different from the rank of the calling process </td></tr>
    <tr><td class="paramname">senddata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04441">4441</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a4791b4e214575bea26bfd84f8f0ffc93" name="a4791b4e214575bea26bfd84f8f0ffc93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4791b4e214575bea26bfd84f8f0ffc93">&#9670;&nbsp;</a></span>ireduce() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ireduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">senddata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the results of the reduction operation if rank equals root_rank, may be nullptr if rank does no equal to root_rank </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03499">3499</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ad2342955984c4db387d52a5414b212c5" name="ad2342955984c4db387d52a5414b212c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2342955984c4db387d52a5414b212c5">&#9670;&nbsp;</a></span>ireduce() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ireduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input data for the reduction operation, will hold the result of the reduction operation if rank equals root_rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04364">4364</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a06525ff878eb073c02dc0bef285f06ac" name="a06525ff878eb073c02dc0bef285f06ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06525ff878eb073c02dc0bef285f06ac">&#9670;&nbsp;</a></span>ireduce() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::ireduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes in non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input buffer for the reduction operation, will hold the results of the reduction operation if rank equals root_rank </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04413">4413</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac5130b267d8d97c911027324fae7b755" name="ac5130b267d8d97c911027324fae7b755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5130b267d8d97c911027324fae7b755">&#9670;&nbsp;</a></span>ireduce_scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ireduce_scatter </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1contiguous__layouts.html">contiguous_layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvcounts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and scatters the result in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input data for the reduction operation, number of elements in buffer senddata must equal the sum of the number of elements given by the collection of layout parameters </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">recvcounts</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03715">3715</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a091a848480618e4d15c28c4443f71d57" name="a091a848480618e4d15c28c4443f71d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091a848480618e4d15c28c4443f71d57">&#9670;&nbsp;</a></span>ireduce_scatter_block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ireduce_scatter_block </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and scatters the result in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input buffer for the reduction operation, number of elements in buffer senddata must equal the size of the communicator </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03642">3642</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a5ece54228622ed7124bd002e203f3652" name="a5ece54228622ed7124bd002e203f3652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ece54228622ed7124bd002e203f3652">&#9670;&nbsp;</a></span>ireduce_scatter_block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::ireduce_scatter_block </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvcount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and scatters the result in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input buffer for the reduction operation, number of elements in buffer senddata must equal the size of the communicator times the number of elements given by the layout parameter </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">recvcount</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03666">3666</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="af60dca19f3de7c889ebc4ede59f6e410" name="af60dca19f3de7c889ebc4ede59f6e410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60dca19f3de7c889ebc4ede59f6e410">&#9670;&nbsp;</a></span>irsend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::irsend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a single value via a non-blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="nonblocking_8cc-example.html#a12">nonblocking.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01503">1503</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="af32a00947a95e27e857a48e6f8b83e05" name="af32a00947a95e27e857a48e6f8b83e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32a00947a95e27e857a48e6f8b83e05">&#9670;&nbsp;</a></span>irsend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::irsend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with several values having a specific memory layout via a non-blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01521">1521</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8e1f39a3a24a7dccd0dfd5f9d6010757" name="a8e1f39a3a24a7dccd0dfd5f9d6010757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1f39a3a24a7dccd0dfd5f9d6010757">&#9670;&nbsp;</a></span>irsend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::irsend </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a non-blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01546">1546</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aced8d70b00a3b407fe3dabac27a99aca" name="aced8d70b00a3b407fe3dabac27a99aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced8d70b00a3b407fe3dabac27a99aca">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mpl::impl::base_communicator::is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a communicator is valid, i.e., is not an empty communicator with no associated process. </p>
<dl class="section return"><dt>Returns</dt><dd>true if communicator is valid </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A default constructed communicator is a non valid communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="communicator_8cc-example.html#a9">communicator.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00482">482</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="afd0aff638a95a6a0003c3993edf014e1" name="afd0aff638a95a6a0003c3993edf014e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0aff638a95a6a0003c3993edf014e1">&#9670;&nbsp;</a></span>iscan() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (scan) over all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03773">3773</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a521c529ae13117f291a9f4fc5086c22a" name="a521c529ae13117f291a9f4fc5086c22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521c529ae13117f291a9f4fc5086c22a">&#9670;&nbsp;</a></span>iscan() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (scan) over all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03794">3794</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a3f51295cbdebc4da6dd7ceebef8c0416" name="a3f51295cbdebc4da6dd7ceebef8c0416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f51295cbdebc4da6dd7ceebef8c0416">&#9670;&nbsp;</a></span>iscan() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::iscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (scan) over all processes in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04581">4581</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac514a6fe8a481f7120bc1d105c09ee96" name="ac514a6fe8a481f7120bc1d105c09ee96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac514a6fe8a481f7120bc1d105c09ee96">&#9670;&nbsp;</a></span>iscan() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::communicator::iscan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction (scan) operation over all processes in a non-blocking manner, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing reduction operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04601">4601</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aba0aee2dd234e053173e8aa2f6732356" name="aba0aee2dd234e053173e8aa2f6732356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0aee2dd234e053173e8aa2f6732356">&#9670;&nbsp;</a></span>iscatter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>data to receive </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02889">2889</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a94de848c2ae1ba01778f6ce94fe9dd69" name="a94de848c2ae1ba01778f6ce94fe9dd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94de848c2ae1ba01778f6ce94fe9dd69">&#9670;&nbsp;</a></span>iscatter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recvdata</td><td>data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02867">2867</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ae62be5f0ed07414914958715bd73ef14" name="ae62be5f0ed07414914958715bd73ef14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62be5f0ed07414914958715bd73ef14">&#9670;&nbsp;</a></span>iscatter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes in a non-blocking manner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recvdata</td><td>data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02937">2937</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aa3dbfd59415b14803d6489ac0280896c" name="aa3dbfd59415b14803d6489ac0280896c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3dbfd59415b14803d6489ac0280896c">&#9670;&nbsp;</a></span>iscatter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes in a non-blocking manner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recvdata</td><td>data to receive </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02955">2955</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a452c129fde4be77ba0322d9416fd2f53" name="a452c129fde4be77ba0322d9416fd2f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452c129fde4be77ba0322d9416fd2f53">&#9670;&nbsp;</a></span>iscatterv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscatterv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>senddispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages with a variable amount of data from a single root process to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">senddispls</td><td>displacements of the data to send by the root rank </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03030">3030</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a66688a6aeec5d0e58662b9a7905ad62b" name="a66688a6aeec5d0e58662b9a7905ad62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66688a6aeec5d0e58662b9a7905ad62b">&#9670;&nbsp;</a></span>iscatterv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscatterv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages with a variable amount of data from a single root process to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03061">3061</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a4b13502e4102508decb2bcef35790e14" name="a4b13502e4102508decb2bcef35790e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b13502e4102508decb2bcef35790e14">&#9670;&nbsp;</a></span>iscatterv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::iscatterv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages with a variable amount of data from a single root process to all processes in a non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03101">3101</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aaa32e597243c8e8870f1a9bc4775862f" name="aaa32e597243c8e8870f1a9bc4775862f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa32e597243c8e8870f1a9bc4775862f">&#9670;&nbsp;</a></span>isend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::isend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a single value via a non-blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="heat_equation__jacobi_method_8cc-example.html#a7">heat_equation_Jacobi_method.cc</a>, <a class="el" href="heat_equation_successive_over-relaxation_8cc-example.html#a7">heat_equation_successive_over-relaxation.cc</a>, <a class="el" href="matrix_gather_8cc-example.html#a7">matrix_gather.cc</a>, <a class="el" href="nonblocking_8cc-example.html#a6">nonblocking.cc</a>, <a class="el" href="nonblocking_mult_8cc-example.html#a4">nonblocking_mult.cc</a>, <a class="el" href="stl_container_8cc-example.html#a3">stl_container.cc</a>, and <a class="el" href="vibrating_string_mpl_8cc-example.html#a6">vibrating_string_mpl.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00644">644</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a713d1e82c0fd9e9c02404fb20dd9115f" name="a713d1e82c0fd9e9c02404fb20dd9115f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713d1e82c0fd9e9c02404fb20dd9115f">&#9670;&nbsp;</a></span>isend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::isend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with several values having a specific memory layout via a non-blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00662">662</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a03d346b0d6e9065f390b9aff3b91b874" name="a03d346b0d6e9065f390b9aff3b91b874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d346b0d6e9065f390b9aff3b91b874">&#9670;&nbsp;</a></span>isend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::isend </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a non-blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00687">687</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="af9a1310602028a6fec86b60d64512cd5" name="af9a1310602028a6fec86b60d64512cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a1310602028a6fec86b60d64512cd5">&#9670;&nbsp;</a></span>issend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::issend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a single value via a non-blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="nonblocking_8cc-example.html#a11">nonblocking.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01227">1227</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a776edf9d2788906192267af47bf74d07" name="a776edf9d2788906192267af47bf74d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776edf9d2788906192267af47bf74d07">&#9670;&nbsp;</a></span>issend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::issend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with several values having a specific memory layout via a non-blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01245">1245</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2f530043606d88ca7f321c6c4c7c14ef" name="a2f530043606d88ca7f321c6c4c7c14ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f530043606d88ca7f321c6c4c7c14ef">&#9670;&nbsp;</a></span>issend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1irequest.html">irequest</a> mpl::impl::base_communicator::issend </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a non-blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>request representing the ongoing message transfer </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01270">1270</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a058e89e1168eed5f1c1045160d299321" name="a058e89e1168eed5f1c1045160d299321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058e89e1168eed5f1c1045160d299321">&#9670;&nbsp;</a></span>mprobe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmpl_1_1mprobe__status.html">mprobe_status</a> mpl::impl::base_communicator::mprobe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking matched test for an incoming message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>message handle and status of the pending message </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01942">1942</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a33937f5473f2424ed10aff8d723b8ca3" name="a33937f5473f2424ed10aff8d723b8ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33937f5473f2424ed10aff8d723b8ca3">&#9670;&nbsp;</a></span>mrecv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::mrecv </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a several values given by a pair of iterators by a message handle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to receive </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to receive </td></tr>
    <tr><td class="paramname">m</td><td>message handle of message to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02026">2026</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a682010694b06d271f397f4e682ff8ef8" name="a682010694b06d271f397f4e682ff8ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682010694b06d271f397f4e682ff8ef8">&#9670;&nbsp;</a></span>mrecv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::mrecv </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a single value by a message handle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to receive </td></tr>
    <tr><td class="paramname">m</td><td>message handle of message to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Receiving STL containers is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01992">1992</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac183e6477f6cc04fa46248de4b4b6eed" name="ac183e6477f6cc04fa46248de4b4b6eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac183e6477f6cc04fa46248de4b4b6eed">&#9670;&nbsp;</a></span>mrecv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::mrecv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacempl.html#a3685893e866d7db6c3b3765d26ef386b">message_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a several values having a specific memory layout by a message handle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to receive </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to receive </td></tr>
    <tr><td class="paramname">m</td><td>message handle of message to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02005">2005</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a43c7b3d19a5af4ba0f30e40045a2e459" name="a43c7b3d19a5af4ba0f30e40045a2e459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c7b3d19a5af4ba0f30e40045a2e459">&#9670;&nbsp;</a></span>neighbor_allgather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_allgather </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all neighboring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send to all neighbours </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00046">46</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="af3ce31d403e1e2c143acb593ca1b21c2" name="af3ce31d403e1e2c143acb593ca1b21c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ce31d403e1e2c143acb593ca1b21c2">&#9670;&nbsp;</a></span>neighbor_allgather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_allgather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages from all neighboring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send to all neighbours </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00061">61</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="af5822b089b634a670a9f3cef6e37dcef" name="af5822b089b634a670a9f3cef6e37dcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5822b089b634a670a9f3cef6e37dcef">&#9670;&nbsp;</a></span>neighbor_allgatherv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_allgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all neighbouring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00137">137</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a377702be1b30166ad458fcef11b2c239" name="a377702be1b30166ad458fcef11b2c239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377702be1b30166ad458fcef11b2c239">&#9670;&nbsp;</a></span>neighbor_allgatherv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_allgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather messages with a variable amount of data from all neighbouring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00119">119</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a455d8703c09913eebe31cd360351c308" name="a455d8703c09913eebe31cd360351c308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455d8703c09913eebe31cd360351c308">&#9670;&nbsp;</a></span>neighbor_alltoall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_alltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all neighbouring processes and receives messages from all neighbouring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layouts of the data to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each neighbouring process and receives elements of type T from each neighbouring process. The memory layouts of the incoming and the outgoing messages are described by sendl and recvl. Both layouts might differ but must be compatible, i.e., must hold the same number of elements of type T. The i-th memory block with the layout sendl in the array senddata is sent to the i-th neighbour. When the function has finished, the i-th memory block with the layout recvl in the array recvdata was received from the i-th neigbour. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00223">223</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a03afcae482e770e40ca5df7ae77b29c6" name="a03afcae482e770e40ca5df7ae77b29c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03afcae482e770e40ca5df7ae77b29c6">&#9670;&nbsp;</a></span>neighbor_alltoall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_alltoall </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages to all neighbouring processes and receives messages from all neighbouring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends one element of type T to each neighbouring process and receives one element of type T from each neighbouring process. The i-th element in the array senddata is sent to the i-th neighbour. When the function has finished, the i-th element in the array recvdata was received from the i-th neighbour. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00199">199</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="ada2dc41f3f09788b9dd87be27981668a" name="ada2dc41f3f09788b9dd87be27981668a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2dc41f3f09788b9dd87be27981668a">&#9670;&nbsp;</a></span>neighbor_alltoallv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_alltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>senddispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>recvdispls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">senddispls</td><td>displacements of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive </td></tr>
    <tr><td class="paramname">recvdispls</td><td>displacements of the data to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each neighbor and receives elements of type T from each neighbour. Send- and receive-data are stored in consecutive blocks of variable size in the buffers senddata and recvdata, respectively. The i-th memory block with the layout sendls[i] in the array senddata starts senddispls[i] bytes after the address given in senddata. The i-th memory block is sent to the i-th neighbor. The i-th memory block with the layout recvls[i] in the array recvdata starts recvdispls[i] bytes after the address given in recvdata. When the function has finished, the i-th memory block in the array recvdata was received from the i-th neighbor. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00307">307</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="a54da0c73668349841c941c53c6acff81" name="a54da0c73668349841c941c53c6acff81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54da0c73668349841c941c53c6acff81">&#9670;&nbsp;</a></span>neighbor_alltoallv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::topology_communicator::neighbor_alltoallv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends messages with a variable amount of data to all neighbouring processes and receives messages with a variable amount of data from all neighbouring processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvls</td><td>memory layouts of the data to receive</td></tr>
  </table>
  </dd>
</dl>
<p>Each process in the communicator sends elements of type T to each neighbour and receives elements of type T from each neighbour. Send- and receive-data are stored in consecutive blocks of variable size in the buffers senddata and recvdata, respectively. The i-th memory block with the layout sendls[i] in the array senddata starts at the address given in senddata. The i-th memory block is sent to the i-th neighbour. The i-th memory block with the layout recvls[i] in the array recvdata starts at the address given in recvdata. Note that the memory layouts need to include appropriate holes at the beginning in order to avoid overlapping send- or receive blocks. When the function has finished, the i-th memory block in the array recvdata was received from the i-th neighbour. </p><dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="topology__communicator_8hpp_source.html#l00341">341</a> of file <a class="el" href="topology__communicator_8hpp_source.html">topology_communicator.hpp</a>.</p>

</div>
</div>
<a id="af39af30840dbd4cdefb3c91b96f80a40" name="af39af30840dbd4cdefb3c91b96f80a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39af30840dbd4cdefb3c91b96f80a40">&#9670;&nbsp;</a></span>neighbors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1graph__communicator_1_1node__list.html">node_list</a> mpl::graph_communicator::neighbors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the neighbours of the calling process. </p>
<dl class="section return"><dt>Returns</dt><dd>direct neighbours of the calling process </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph__communicator_8hpp_source.html#l00216">216</a> of file <a class="el" href="graph__communicator_8hpp_source.html">graph_communicator.hpp</a>.</p>

</div>
</div>
<a id="ad517010b26940090a839b6ef0c3d95ad" name="ad517010b26940090a839b6ef0c3d95ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad517010b26940090a839b6ef0c3d95ad">&#9670;&nbsp;</a></span>neighbors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1graph__communicator_1_1node__list.html">node_list</a> mpl::graph_communicator::neighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the neighbours of some process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>process rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>direct neighbours of the process with the given rank </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph__communicator_8hpp_source.html#l00207">207</a> of file <a class="el" href="graph__communicator_8hpp_source.html">graph_communicator.hpp</a>.</p>

</div>
</div>
<a id="aea3f30e3e33676cfbd8f3757082949cd" name="aea3f30e3e33676cfbd8f3757082949cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3f30e3e33676cfbd8f3757082949cd">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mpl::communicator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1communicator.html">communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for identity of communicators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>communicator to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if not identical </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04012">4012</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="adce11d71ed0d0398316f5a5669b5bdbf" name="adce11d71ed0d0398316f5a5669b5bdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce11d71ed0d0398316f5a5669b5bdbf">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1graph__communicator.html">graph_communicator</a> &amp; mpl::graph_communicator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1graph__communicator.html">graph_communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-assigns and creates a new communicator with graph process topology which is equivalent to an existing one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other communicator to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation that needs to be carried out by all processes of the communicator other. Communicators should not be copied unless a new independent communicator is wanted. Communicators should be passed via references to functions to avoid unnecessary copying. </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph__communicator_8hpp_source.html#l00158">158</a> of file <a class="el" href="graph__communicator_8hpp_source.html">graph_communicator.hpp</a>.</p>

</div>
</div>
<a id="a9c706fcf6770f01b69256c7f76c97222" name="a9c706fcf6770f01b69256c7f76c97222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c706fcf6770f01b69256c7f76c97222">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1graph__communicator.html">graph_communicator</a> &amp; mpl::graph_communicator::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmpl_1_1graph__communicator.html">graph_communicator</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assigns a communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other communicator to move from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation that needs to be carried out by all processes of the communicator other. </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph__communicator_8hpp_source.html#l00177">177</a> of file <a class="el" href="graph__communicator_8hpp_source.html">graph_communicator.hpp</a>.</p>

</div>
</div>
<a id="a153a492a90432d228638e2548b2a65b5" name="a153a492a90432d228638e2548b2a65b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a153a492a90432d228638e2548b2a65b5">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mpl::communicator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1communicator.html">communicator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for identity of communicators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>communicator to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if identical </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04007">4007</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8ed051ae1ad9ea893018ee0b1d98b9ec" name="a8ed051ae1ad9ea893018ee0b1d98b9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed051ae1ad9ea893018ee0b1d98b9ec">&#9670;&nbsp;</a></span>probe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::probe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking test for an incoming message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the pending message </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="probe_8cc-example.html#a7">probe.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01911">1911</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ae07d74b4f28b45e4bf56777d5d2a9789" name="ae07d74b4f28b45e4bf56777d5d2a9789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07d74b4f28b45e4bf56777d5d2a9789">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mpl::communicator::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the rank within a communicator. </p>
<dl class="section return"><dt>Returns</dt><dd>the rank of the calling process in the communicator </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="arrays_8cc-example.html#a4">arrays.cc</a>, <a class="el" href="blocking_8cc-example.html#a3">blocking.cc</a>, <a class="el" href="blocking_vector_8cc-example.html#a4">blocking_vector.cc</a>, <a class="el" href="collective_8cc-example.html#a4">collective.cc</a>, <a class="el" href="communicator_8cc-example.html#a2">communicator.cc</a>, <a class="el" href="distributed_grid_scatter_gather_8cc-example.html#a17">distributed_grid_scatter_gather.cc</a>, <a class="el" href="gather_8cc-example.html#a2">gather.cc</a>, <a class="el" href="gatherv_8cc-example.html#a2">gatherv.cc</a>, <a class="el" href="hello_world_8cc-example.html#a3">hello_world.cc</a>, <a class="el" href="intercommunicator_8cc-example.html#a2">intercommunicator.cc</a>, <a class="el" href="iterators_8cc-example.html#a4">iterators.cc</a>, <a class="el" href="layouts_8cc-example.html#a3">layouts.cc</a>, <a class="el" href="matrix_gather_8cc-example.html#a3">matrix_gather.cc</a>, <a class="el" href="nonblocking_8cc-example.html#a4">nonblocking.cc</a>, <a class="el" href="nonblocking_mult_8cc-example.html#a2">nonblocking_mult.cc</a>, <a class="el" href="parallel_sort_mpl_8cc-example.html#a1">parallel_sort_mpl.cc</a>, <a class="el" href="probe_8cc-example.html#a3">probe.cc</a>, <a class="el" href="reduce_lcm_8cc-example.html#a2">reduce_lcm.cc</a>, <a class="el" href="reduce_min_loc_8cc-example.html#a2">reduce_min_loc.cc</a>, <a class="el" href="standard_types_8cc-example.html#a6">standard_types.cc</a>, <a class="el" href="stl_container_8cc-example.html#a11">stl_container.cc</a>, <a class="el" href="struct_8cc-example.html#a4">struct.cc</a>, <a class="el" href="subarray_8cc-example.html#a3">subarray.cc</a>, and <a class="el" href="vibrating_string_mpl_8cc-example.html#a3">vibrating_string_mpl.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04002">4002</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a41379e1fb24e1a2bd826f8168d65be74" name="a41379e1fb24e1a2bd826f8168d65be74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41379e1fb24e1a2bd826f8168d65be74">&#9670;&nbsp;</a></span>recv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::recv </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a several values given by a pair of iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to receive </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01724">1724</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8ed451f2d5ea46348a1e4ca1ecd84ee8" name="a8ed451f2d5ea46348a1e4ca1ecd84ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed451f2d5ea46348a1e4ca1ecd84ee8">&#9670;&nbsp;</a></span>recv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::recv </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a single value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Receiving STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. <a class="anchor" id="communicator_recv"></a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="arrays_8cc-example.html#a6">arrays.cc</a>, <a class="el" href="blocking_8cc-example.html#a10">blocking.cc</a>, <a class="el" href="blocking_vector_8cc-example.html#a11">blocking_vector.cc</a>, <a class="el" href="hello_world_8cc-example.html#a6">hello_world.cc</a>, <a class="el" href="iterators_8cc-example.html#a6">iterators.cc</a>, <a class="el" href="layouts_8cc-example.html#a6">layouts.cc</a>, <a class="el" href="matrix_gather_8cc-example.html#a8">matrix_gather.cc</a>, <a class="el" href="probe_8cc-example.html#a11">probe.cc</a>, <a class="el" href="reduce_lcm_8cc-example.html#a6">reduce_lcm.cc</a>, <a class="el" href="reduce_min_loc_8cc-example.html#a7">reduce_min_loc.cc</a>, <a class="el" href="standard_types_8cc-example.html#a2">standard_types.cc</a>, <a class="el" href="stl_container_8cc-example.html#a5">stl_container.cc</a>, <a class="el" href="struct_8cc-example.html#a6">struct.cc</a>, and <a class="el" href="subarray_8cc-example.html#a7">subarray.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01686">1686</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a5cce3b6810686d34edb81b0fcf6d7874" name="a5cce3b6810686d34edb81b0fcf6d7874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cce3b6810686d34edb81b0fcf6d7874">&#9670;&nbsp;</a></span>recv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::recv </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message with a several values having a specific memory layout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to receive </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01701">1701</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2a5fba6ec72344fcfb29e31907b2ff15" name="a2a5fba6ec72344fcfb29e31907b2ff15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5fba6ec72344fcfb29e31907b2ff15">&#9670;&nbsp;</a></span>recv_init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::recv_init </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to receive a message with a several values given by a pair of iterators via a blocking receive operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to receive </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending ing process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01894">1894</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a33b9722648c47d6751a5195cfbf49e9d" name="a33b9722648c47d6751a5195cfbf49e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b9722648c47d6751a5195cfbf49e9d">&#9670;&nbsp;</a></span>recv_init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::recv_init </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to receive a message with a single value via a blocking receive operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Receiving STL containers is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01851">1851</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac49140cee541e8ade8a21b724ddeb189" name="ac49140cee541e8ade8a21b724ddeb189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49140cee541e8ade8a21b724ddeb189">&#9670;&nbsp;</a></span>recv_init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::recv_init </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to receive a message with a several values having a specific memory layout via a blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to receive, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to receive </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01870">1870</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a494c7c1849713e45d99d901b31250b35" name="a494c7c1849713e45d99d901b31250b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494c7c1849713e45d99d901b31250b35">&#9670;&nbsp;</a></span>reduce() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::reduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes, non-root in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result, must be different from the rank of the calling process </td></tr>
    <tr><td class="paramname">senddata</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04301">4301</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a83611f07b8b4d986e4afd1f93928c887" name="a83611f07b8b4d986e4afd1f93928c887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83611f07b8b4d986e4afd1f93928c887">&#9670;&nbsp;</a></span>reduce() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::reduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">senddata</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the result of the reduction operation if rank equals root_rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03434">3434</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aed2415ddb3e27cce97fd5317f781a86c" name="aed2415ddb3e27cce97fd5317f781a86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2415ddb3e27cce97fd5317f781a86c">&#9670;&nbsp;</a></span>reduce() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::reduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes, non-root in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result, must be different from the rank of the calling process </td></tr>
    <tr><td class="paramname">senddata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04343">4343</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a6f35d0b54b37c35d4a9408988afebaec" name="a6f35d0b54b37c35d4a9408988afebaec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f35d0b54b37c35d4a9408988afebaec">&#9670;&nbsp;</a></span>reduce() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::reduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">senddata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the results of the reduction operation if rank equals root_rank, may be nullptr if rank does no equal to root_rank </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. <a class="anchor" id="communicator_reduce_contiguous_layout"></a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03455">3455</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="adb886db659e8bc352ca70800704b8956" name="adb886db659e8bc352ca70800704b8956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb886db659e8bc352ca70800704b8956">&#9670;&nbsp;</a></span>reduce() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::reduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input data for the reduction operation, will hold the result of the reduction operation if rank equals root_rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="collective_8cc-example.html#a9">collective.cc</a>, <a class="el" href="reduce_lcm_8cc-example.html#a4">reduce_lcm.cc</a>, and <a class="el" href="reduce_min_loc_8cc-example.html#a4">reduce_min_loc.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04279">4279</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aae3643fa3e833c9dfb4eaf871235aed3" name="aae3643fa3e833c9dfb4eaf871235aed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3643fa3e833c9dfb4eaf871235aed3">&#9670;&nbsp;</a></span>reduce() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::reduce </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">root_rank</td><td>rank of the process that will receive the reduction result </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input buffer for the reduction operation, will hold the results of the reduction operation if rank equals root_rank </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04320">4320</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a5c9d1f2b9b2156b9624cdabda0d59216" name="a5c9d1f2b9b2156b9624cdabda0d59216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9d1f2b9b2156b9624cdabda0d59216">&#9670;&nbsp;</a></span>reduce_scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::reduce_scatter </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layouts.html">contiguous_layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvcounts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and scatters the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input data for the reduction operation, number of elements in buffer senddata must equal the sum of the number of elements given by the collection of layout parameters </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">recvcounts</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03691">3691</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8504097e2a5054c2411a23e515b8fb2f" name="a8504097e2a5054c2411a23e515b8fb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8504097e2a5054c2411a23e515b8fb2f">&#9670;&nbsp;</a></span>reduce_scatter_block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::reduce_scatter_block </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and scatters the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input data for the reduction operation, number of elements in buffer senddata must equal the size of the communicator </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03600">3600</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a6770e234f2ed37f5bcabd76725d1c645" name="a6770e234f2ed37f5bcabd76725d1c645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6770e234f2ed37f5bcabd76725d1c645">&#9670;&nbsp;</a></span>reduce_scatter_block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::reduce_scatter_block </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvcount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a reduction operation over all processes and scatters the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input data for the reduction operation, number of elements in buffer senddata must equal the size of the communicator times the number of elements given by the layout parameter </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">recvcount</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03620">3620</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a5b00ddafa6438961cd3e05ce22a96afb" name="a5b00ddafa6438961cd3e05ce22a96afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b00ddafa6438961cd3e05ce22a96afb">&#9670;&nbsp;</a></span>rsend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::rsend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a single value via a blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="blocking_8cc-example.html#a9">blocking.cc</a>, and <a class="el" href="blocking_vector_8cc-example.html#a10">blocking_vector.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01388">1388</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a257bd4af8e5d09ef8967e32144693b1b" name="a257bd4af8e5d09ef8967e32144693b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257bd4af8e5d09ef8967e32144693b1b">&#9670;&nbsp;</a></span>rsend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::rsend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values having a specific memory layout via a blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01404">1404</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a995f7850daaf8ea3347dd942af00db8f" name="a995f7850daaf8ea3347dd942af00db8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995f7850daaf8ea3347dd942af00db8f">&#9670;&nbsp;</a></span>rsend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::rsend </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01425">1425</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a9b00350327fd0656ddd4420f3c41176a" name="a9b00350327fd0656ddd4420f3c41176a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b00350327fd0656ddd4420f3c41176a">&#9670;&nbsp;</a></span>rsend_init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::rsend_init </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a single value via a blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01570">1570</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a46ed4b2b4436f29466c1bab7164b37b7" name="a46ed4b2b4436f29466c1bab7164b37b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ed4b2b4436f29466c1bab7164b37b7">&#9670;&nbsp;</a></span>rsend_init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::rsend_init </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values having a specific memory layout via a blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01589">1589</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aa2fc8191506235854c21335e59e3de67" name="aa2fc8191506235854c21335e59e3de67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fc8191506235854c21335e59e3de67">&#9670;&nbsp;</a></span>rsend_init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::rsend_init </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values given by a pair of iterators via a blocking ready send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01614">1614</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a3438765595e8f2e405a093fc5e9c205a" name="a3438765595e8f2e405a093fc5e9c205a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3438765595e8f2e405a093fc5e9c205a">&#9670;&nbsp;</a></span>scan() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs partial reduction operation (scan) over all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input data for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the result of the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03737">3737</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aea16fe68468a0a2dfbfadc10a921fb7f" name="aea16fe68468a0a2dfbfadc10a921fb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea16fe68468a0a2dfbfadc10a921fb7f">&#9670;&nbsp;</a></span>scan() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (scan) over all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">senddata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">recvdata</td><td>will hold the results of the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03754">3754</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aa06dee1bcc8345dc0c83f215dea4aba6" name="aa06dee1bcc8345dc0c83f215dea4aba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06dee1bcc8345dc0c83f215dea4aba6">&#9670;&nbsp;</a></span>scan() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::scan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (scan) over all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input data for the reduction operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04546">4546</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="afe6c73aa613bf07ed4790210f10a0f1c" name="afe6c73aa613bf07ed4790210f10a0f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6c73aa613bf07ed4790210f10a0f1c">&#9670;&nbsp;</a></span>scan() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::communicator::scan </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendrecvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1contiguous__layout.html">contiguous_layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a partial reduction operation (scan) over all processes, in-place variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type representing the element-wise reduction operation, reduction operation is performed on data of type T </td></tr>
    <tr><td class="paramname">T</td><td>type of input and output data of the reduction operation, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>reduction operation </td></tr>
    <tr><td class="paramname">sendrecvdata</td><td>input buffer for the reduction operation </td></tr>
    <tr><td class="paramname">l</td><td>memory layouts of the data to send and to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04563">4563</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a24ccfd59e06701d3fdfb425dc1cba3ad" name="a24ccfd59e06701d3fdfb425dc1cba3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ccfd59e06701d3fdfb425dc1cba3ad">&#9670;&nbsp;</a></span>scatter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>data to receive </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02846">2846</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a5076229b612f84540cb27b0bf81d114d" name="a5076229b612f84540cb27b0bf81d114d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5076229b612f84540cb27b0bf81d114d">&#9670;&nbsp;</a></span>scatter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">recvdata</td><td>data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="collective_8cc-example.html#a8">collective.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02828">2828</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a68e66c5b2cc66e616896c1aeb5fc267b" name="a68e66c5b2cc66e616896c1aeb5fc267b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e66c5b2cc66e616896c1aeb5fc267b">&#9670;&nbsp;</a></span>scatter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recvdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recvdata</td><td>data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02907">2907</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="abbaa6c0a4206bd18084d9a4aeff407b3" name="abbaa6c0a4206bd18084d9a4aeff407b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbaa6c0a4206bd18084d9a4aeff407b3">&#9670;&nbsp;</a></span>scatter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scatter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages from a single root process to all processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recvdata</td><td>data to receive </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02921">2921</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a04bf73d794343073b39d65c699b5d143" name="a04bf73d794343073b39d65c699b5d143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bf73d794343073b39d65c699b5d143">&#9670;&nbsp;</a></span>scatterv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scatterv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1displacements.html">displacements</a> &amp;&#160;</td>
          <td class="paramname"><em>senddispls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages with a variable amount of data from a single root process to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">senddispls</td><td>displacements of the data to send by the root rank </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="distributed_grid_scatter_gather_8cc-example.html#a3">distributed_grid_scatter_gather.cc</a>, <a class="el" href="heat_equation__jacobi_method_8cc-example.html#a17">heat_equation_Jacobi_method.cc</a>, and <a class="el" href="heat_equation_successive_over-relaxation_8cc-example.html#a18">heat_equation_successive_over-relaxation.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02980">2980</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a9b766673f41b3bb395c4ee5eeb69358e" name="a9b766673f41b3bb395c4ee5eeb69358e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b766673f41b3bb395c4ee5eeb69358e">&#9670;&nbsp;</a></span>scatterv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scatterv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layouts.html">layouts</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages with a variable amount of data from a single root process to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">senddata</td><td>pointer to continuous storage for outgoing messages, may be a null pointer at non-root processes </td></tr>
    <tr><td class="paramname">sendls</td><td>memory layouts of the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03009">3009</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a7e0f08cd1f0f2ed77ad06f636360aabc" name="a7e0f08cd1f0f2ed77ad06f636360aabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0f08cd1f0f2ed77ad06f636360aabc">&#9670;&nbsp;</a></span>scatterv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::scatterv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter messages with a variable amount of data from a single root process to all processes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_rank</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recvdata</td><td>pointer to continuous storage for incoming messages </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive by the root rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a collective operation and must be called (possibly by utilizing anther overload) by all processes in the communicator. This particular overload can only be called by non-root processes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03078">3078</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac3b0e731726a939727ff816a614d241b" name="ac3b0e731726a939727ff816a614d241b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b0e731726a939727ff816a614d241b">&#9670;&nbsp;</a></span>send() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::send </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a single value via a blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="arrays_8cc-example.html#a5">arrays.cc</a>, <a class="el" href="blocking_8cc-example.html#a4">blocking.cc</a>, <a class="el" href="blocking_vector_8cc-example.html#a5">blocking_vector.cc</a>, <a class="el" href="hello_world_8cc-example.html#a5">hello_world.cc</a>, <a class="el" href="iterators_8cc-example.html#a5">iterators.cc</a>, <a class="el" href="layouts_8cc-example.html#a5">layouts.cc</a>, <a class="el" href="probe_8cc-example.html#a5">probe.cc</a>, <a class="el" href="reduce_lcm_8cc-example.html#a7">reduce_lcm.cc</a>, <a class="el" href="reduce_min_loc_8cc-example.html#a8">reduce_min_loc.cc</a>, <a class="el" href="standard_types_8cc-example.html#a1">standard_types.cc</a>, <a class="el" href="stl_container_8cc-example.html#a1">stl_container.cc</a>, <a class="el" href="struct_8cc-example.html#a5">struct.cc</a>, and <a class="el" href="subarray_8cc-example.html#a5">subarray.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00529">529</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a990f2e09f7d92480615e90cc16457316" name="a990f2e09f7d92480615e90cc16457316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990f2e09f7d92480615e90cc16457316">&#9670;&nbsp;</a></span>send() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::send </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values having a specific memory layout via a blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00545">545</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a2830d8cf5f8e9b162e899cf54f07bca9" name="a2830d8cf5f8e9b162e899cf54f07bca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2830d8cf5f8e9b162e899cf54f07bca9">&#9670;&nbsp;</a></span>send() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::send </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00566">566</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a7982f8625c5078750d1fa544b11fb9bf" name="a7982f8625c5078750d1fa544b11fb9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7982f8625c5078750d1fa544b11fb9bf">&#9670;&nbsp;</a></span>send_init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::send_init </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a single value via a blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00711">711</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a8af8b0ee87ebfade234ff3f885cb1799" name="a8af8b0ee87ebfade234ff3f885cb1799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af8b0ee87ebfade234ff3f885cb1799">&#9670;&nbsp;</a></span>send_init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::send_init </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values having a specific memory layout via a blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00730">730</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a914d0001e76d3f0b12b16bf7f4e6aceb" name="a914d0001e76d3f0b12b16bf7f4e6aceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914d0001e76d3f0b12b16bf7f4e6aceb">&#9670;&nbsp;</a></span>send_init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::send_init </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values given by a pair of iterators via a blocking standard send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00755">755</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a84985acac072b195e21cfd2b69220ab8" name="a84985acac072b195e21cfd2b69220ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84985acac072b195e21cfd2b69220ab8">&#9670;&nbsp;</a></span>sendrecv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::sendrecv </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>sendtag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>recvtag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message and receives a message in a single operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">sendtag</td><td>tag associated to the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>data to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recvtag</td><td>tag associated to the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="distributed_grid_8cc-example.html#a4">distributed_grid.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02117">2117</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="af2cc26da5ac38e24691752bfcd7d9c26" name="af2cc26da5ac38e24691752bfcd7d9c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cc26da5ac38e24691752bfcd7d9c26">&#9670;&nbsp;</a></span>sendrecv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::sendrecv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>senddata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sendl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>sendtag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>recvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>recvtag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message and receives a message in a single operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senddata</td><td>data to send </td></tr>
    <tr><td class="paramname">sendl</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">sendtag</td><td>tag associated to the data to send </td></tr>
    <tr><td class="paramname">recvdata</td><td>data to receive </td></tr>
    <tr><td class="paramname">recvl</td><td>memory layout of the data to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recvtag</td><td>tag associated to the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02144">2144</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a83aac396a46f8b7287225b6b404c6789" name="a83aac396a46f8b7287225b6b404c6789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83aac396a46f8b7287225b6b404c6789">&#9670;&nbsp;</a></span>sendrecv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT1 , typename iterT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::sendrecv </td>
          <td>(</td>
          <td class="paramtype">iterT1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>sendtag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>recvtag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message and receives a message in a single operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT1</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
    <tr><td class="paramname">iterT2</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin1</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end1</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">sendtag</td><td>tag associated to the data to send </td></tr>
    <tr><td class="paramname">begin2</td><td>iterator pointing to the first data value to receive </td></tr>
    <tr><td class="paramname">end2</td><td>iterator pointing one element beyond the last data value to receive </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recvtag</td><td>tag associated to the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02180">2180</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aca5779a5778f565ea5857cd5b7c7b3c4" name="aca5779a5778f565ea5857cd5b7c7b3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5779a5778f565ea5857cd5b7c7b3c4">&#9670;&nbsp;</a></span>sendrecv_replace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::sendrecv_replace </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>sendtag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>recvtag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message and receives a message in a single operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send and to receive </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send and to receive </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">sendtag</td><td>tag associated to the data to send </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recvtag</td><td>tag associated to the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02271">2271</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a6a713de3261c9b7667f754ac587ba6ce" name="a6a713de3261c9b7667f754ac587ba6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a713de3261c9b7667f754ac587ba6ce">&#9670;&nbsp;</a></span>sendrecv_replace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::sendrecv_replace </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>sendtag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>recvtag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message and receives a message in a single operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>data to send, will hold the received data </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">sendtag</td><td>tag associated to the data to send </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recvtag</td><td>tag associated to the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02219">2219</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac094726cff7f3be751bb3ab3cbc5b178" name="ac094726cff7f3be751bb3ab3cbc5b178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac094726cff7f3be751bb3ab3cbc5b178">&#9670;&nbsp;</a></span>sendrecv_replace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1status__t.html">status_t</a> mpl::impl::base_communicator::sendrecv_replace </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>sendtag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>recvtag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message and receives a message in a single operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>data to send, will hold the received data </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send and receive </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">sendtag</td><td>tag associated to the data to send </td></tr>
    <tr><td class="paramname">source</td><td>rank of the sending process </td></tr>
    <tr><td class="paramname">recvtag</td><td>tag associated to the data to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the receive operation </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l02243">2243</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="abe1bd8f32c690ee7a31456da2c437bdf" name="abe1bd8f32c690ee7a31456da2c437bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1bd8f32c690ee7a31456da2c437bdf">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mpl::communicator::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the total number of processes in a communicator. </p>
<dl class="section return"><dt>Returns</dt><dd>number of processes </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="arrays_8cc-example.html#a2">arrays.cc</a>, <a class="el" href="blocking_8cc-example.html#a2">blocking.cc</a>, <a class="el" href="blocking_vector_8cc-example.html#a2">blocking_vector.cc</a>, <a class="el" href="collective_8cc-example.html#a6">collective.cc</a>, <a class="el" href="communicator_8cc-example.html#a3">communicator.cc</a>, <a class="el" href="distributed_grid_8cc-example.html#a15">distributed_grid.cc</a>, <a class="el" href="distributed_grid_scatter_gather_8cc-example.html#a15">distributed_grid_scatter_gather.cc</a>, <a class="el" href="gather_8cc-example.html#a3">gather.cc</a>, <a class="el" href="gatherv_8cc-example.html#a3">gatherv.cc</a>, <a class="el" href="heat_equation__jacobi_method_8cc-example.html#a27">heat_equation_Jacobi_method.cc</a>, <a class="el" href="heat_equation_successive_over-relaxation_8cc-example.html#a28">heat_equation_successive_over-relaxation.cc</a>, <a class="el" href="hello_world_8cc-example.html#a4">hello_world.cc</a>, <a class="el" href="iterators_8cc-example.html#a2">iterators.cc</a>, <a class="el" href="layouts_8cc-example.html#a2">layouts.cc</a>, <a class="el" href="matrix_gather_8cc-example.html#a2">matrix_gather.cc</a>, <a class="el" href="nonblocking_8cc-example.html#a2">nonblocking.cc</a>, <a class="el" href="nonblocking_mult_8cc-example.html#a5">nonblocking_mult.cc</a>, <a class="el" href="parallel_sort_mpl_8cc-example.html#a2">parallel_sort_mpl.cc</a>, <a class="el" href="probe_8cc-example.html#a2">probe.cc</a>, <a class="el" href="reduce_lcm_8cc-example.html#a5">reduce_lcm.cc</a>, <a class="el" href="reduce_min_loc_8cc-example.html#a6">reduce_min_loc.cc</a>, <a class="el" href="standard_types_8cc-example.html#a4">standard_types.cc</a>, <a class="el" href="stl_container_8cc-example.html#a9">stl_container.cc</a>, <a class="el" href="struct_8cc-example.html#a2">struct.cc</a>, <a class="el" href="subarray_8cc-example.html#a2">subarray.cc</a>, and <a class="el" href="vibrating_string_mpl_8cc-example.html#a2">vibrating_string_mpl.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l03998">3998</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a63be7ddf6ff0ffa1030ff353e05acc79" name="a63be7ddf6ff0ffa1030ff353e05acc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63be7ddf6ff0ffa1030ff353e05acc79">&#9670;&nbsp;</a></span>ssend() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::ssend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a single value via a blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section or an STL container that holds elements that comply with the mentioned requirements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is a convenience feature, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="blocking_8cc-example.html#a8">blocking.cc</a>, and <a class="el" href="blocking_vector_8cc-example.html#a9">blocking_vector.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01112">1112</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a842c446804617b143a71c6f4158f6cd9" name="a842c446804617b143a71c6f4158f6cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842c446804617b143a71c6f4158f6cd9">&#9670;&nbsp;</a></span>ssend() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::ssend </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values having a specific memory layout via a blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01127">1127</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a862ca31669e1d87b2a1c21dedc8e8cbc" name="a862ca31669e1d87b2a1c21dedc8e8cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862ca31669e1d87b2a1c21dedc8e8cbc">&#9670;&nbsp;</a></span>ssend() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mpl::impl::base_communicator::ssend </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message with a several values given by a pair of iterators via a blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01148">1148</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="abd73358c63baca47dc8807c4a2ee2b65" name="abd73358c63baca47dc8807c4a2ee2b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd73358c63baca47dc8807c4a2ee2b65">&#9670;&nbsp;</a></span>ssend_init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::ssend_init </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a single value via a blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sending STL containers is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01293">1293</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a7a7c5d8b854ecb53490d905bf9f69053" name="a7a7c5d8b854ecb53490d905bf9f69053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7c5d8b854ecb53490d905bf9f69053">&#9670;&nbsp;</a></span>ssend_init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::ssend_init </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmpl_1_1layout.html">layout</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values having a specific memory layout via a blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the data to send, must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>pointer to the data to send </td></tr>
    <tr><td class="paramname">l</td><td>memory layout of the data to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01312">1312</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a07640680936f14f3ace0d1d7539f3b19" name="a07640680936f14f3ace0d1d7539f3b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07640680936f14f3ace0d1d7539f3b19">&#9670;&nbsp;</a></span>ssend_init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmpl_1_1prequest.html">prequest</a> mpl::impl::base_communicator::ssend_init </td>
          <td>(</td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterT&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="classmpl_1_1tag__t.html">tag_t</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a persistent communication request to send a message with a several values given by a pair of iterators via a blocking synchronous send operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterT</td><td>iterator type, must fulfill the requirements of a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">LegacyForwardIterator</a>, the iterator's value-type must meet the requirements as described in the <a class="el" href="md_data_types.html#data_types">data types</a> section </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator pointing to the first data value to send </td></tr>
    <tr><td class="paramname">end</td><td>iterator pointing one element beyond the last data value to send </td></tr>
    <tr><td class="paramname">destination</td><td>rank of the receiving process </td></tr>
    <tr><td class="paramname">t</td><td>tag associated to this message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>persistent communication request </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a convenience method, which may have non-optimal performance characteristics. Use alternative overloads in performance critical code sections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l01337">1337</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acc25b99129227cb025c31e1d12f97cde" name="acc25b99129227cb025c31e1d12f97cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc25b99129227cb025c31e1d12f97cde">&#9670;&nbsp;</a></span>comm_collective</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1comm__collective__tag.html">comm_collective_tag</a> mpl::impl::base_communicator::comm_collective {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the creation of a new communicator by an operation that is collective for all processes in the given communicator. </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00384">384</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="aec5ab4324f1a084a93edbbab08bc3d91" name="aec5ab4324f1a084a93edbbab08bc3d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5ab4324f1a084a93edbbab08bc3d91">&#9670;&nbsp;</a></span>congruent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a> mpl::communicator::congruent = equality_type::congruent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >indicates that communicators are identical, i.e., communicators have same the members in same rank order but different context </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04034">4034</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a3be74464ba28c4bb3022029fa7f13f40" name="a3be74464ba28c4bb3022029fa7f13f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be74464ba28c4bb3022029fa7f13f40">&#9670;&nbsp;</a></span>group_collective</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1group__collective__tag.html">group_collective_tag</a> mpl::impl::base_communicator::group_collective {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the creation of a new communicator by an operation that is collective for all processes in the given group. </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00391">391</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="ac66083dad051e6b7042d47962d1e2c60" name="ac66083dad051e6b7042d47962d1e2c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66083dad051e6b7042d47962d1e2c60">&#9670;&nbsp;</a></span>identical</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a> mpl::communicator::identical = equality_type::identical</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >indicates that communicators are identical, i.e., communicators represent the same communication context </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04031">4031</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="abe7076a9aaa13cb078e700c0cb616f3f" name="abe7076a9aaa13cb078e700c0cb616f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7076a9aaa13cb078e700c0cb616f3f">&#9670;&nbsp;</a></span>similar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a> mpl::communicator::similar = equality_type::similar</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >indicates that communicators are similar, i.e., communicators have same tha members in different rank order </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04037">4037</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a32074b289551af82033ef77c90b47431" name="a32074b289551af82033ef77c90b47431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32074b289551af82033ef77c90b47431">&#9670;&nbsp;</a></span>split</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1split__tag.html">split_tag</a> mpl::impl::base_communicator::split {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the creation of a new communicator by spitting an existing communicator into disjoint subgroups. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="communicator_8cc-example.html#a5">communicator.cc</a>, and <a class="el" href="intercommunicator_8cc-example.html#a3">intercommunicator.cc</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00398">398</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="abb9392fc67c9b2d22a9e429e834937fc" name="abb9392fc67c9b2d22a9e429e834937fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9392fc67c9b2d22a9e429e834937fc">&#9670;&nbsp;</a></span>split_shared_memory</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1impl_1_1base__communicator_1_1split__shared__memory__tag.html">split_shared_memory_tag</a> mpl::impl::base_communicator::split_shared_memory {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the creation of a new communicator by spitting an existing communicator into disjoint subgroups each of which can create a shared memory region. </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l00405">405</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<a id="a10097f544da37d6c9c73606409ed151a" name="a10097f544da37d6c9c73606409ed151a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10097f544da37d6c9c73606409ed151a">&#9670;&nbsp;</a></span>unequal</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmpl_1_1communicator.html#af66054a704ac25557aa25b356e8abd63">equality_type</a> mpl::communicator::unequal = equality_type::unequal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >indicates that communicators are unequal, i.e., communicators have different sets of members </p>

<p class="definition">Definition at line <a class="el" href="comm__group_8hpp_source.html#l04040">4040</a> of file <a class="el" href="comm__group_8hpp_source.html">comm_group.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="graph__communicator_8hpp_source.html">graph_communicator.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacempl.html">mpl</a></li><li class="navelem"><a class="el" href="classmpl_1_1graph__communicator.html">graph_communicator</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
